Mobjects
Class Name,Module,File Path,Description
FullScreenRectangle,manim.mobject.frame,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/frame.py,"A quadrilateral with two sets of parallel sides.  Parameters ---------- color     The color of the rectangle. height     The vertical height of the rectangle. width     The horizontal width of the rectangle. grid_xstep     Space between vertical grid lines. grid_ystep     Space between horizontal grid lines. mark_paths_closed     No purpose. close_new_points     No purpose. kwargs     Additional arguments to be passed to :class:`Polygon`  Examples ---------- .. manim:: RectangleExample     :save_last_frame:      class RectangleExample(Scene):         def construct(self):             rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)             rect2 = Rectangle(width=1.0, height=4.0)             rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)             rect3.grid_lines.set_stroke(width=1)              rects = Group(rect1, rect2, rect3).arrange(buff=1)             self.add(rects)"
ScreenRectangle,manim.mobject.frame,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/frame.py,"A quadrilateral with two sets of parallel sides.  Parameters ---------- color     The color of the rectangle. height     The vertical height of the rectangle. width     The horizontal width of the rectangle. grid_xstep     Space between vertical grid lines. grid_ystep     Space between horizontal grid lines. mark_paths_closed     No purpose. close_new_points     No purpose. kwargs     Additional arguments to be passed to :class:`Polygon`  Examples ---------- .. manim:: RectangleExample     :save_last_frame:      class RectangleExample(Scene):         def construct(self):             rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)             rect2 = Rectangle(width=1.0, height=4.0)             rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)             rect3.grid_lines.set_stroke(width=1)              rects = Group(rect1, rect2, rect3).arrange(buff=1)             self.add(rects)"
AnnotationDot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,A dot with bigger radius and bold stroke to annotate scenes.
AnnularSector,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A sector of an annulus.   Parameters ---------- inner_radius    The inside radius of the Annular Sector. outer_radius    The outside radius of the Annular Sector. angle    The clockwise angle of the Annular Sector. start_angle    The starting clockwise angle of the Annular Sector. fill_opacity    The opacity of the color filled in the Annular Sector. stroke_width    The stroke width of the Annular Sector. color    The color filled into the Annular Sector.  Examples -------- .. manim:: AnnularSectorExample     :save_last_frame:      class AnnularSectorExample(Scene):         def construct(self):             # Changes background color to clearly visualize changes in fill_opacity.             self.camera.background_color = WHITE              # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.             s1 = AnnularSector(color=YELLOW).move_to(2 * UL)              # Different inner_radius and outer_radius than the default.             s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)              # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.             s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)              # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.             s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)              self.add(s1, s2, s3, s4)"
Annulus,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Region between two concentric :class:`Circles <.Circle>`.  Parameters ---------- inner_radius     The radius of the inner :class:`Circle`. outer_radius     The radius of the outer :class:`Circle`. kwargs     Additional arguments to be passed to :class:`Annulus`  Examples -------- .. manim:: AnnulusExample     :save_last_frame:      class AnnulusExample(Scene):         def construct(self):             annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)             annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)             self.add(annulus_1, annulus_2)"
Arc,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,A circular arc.  Examples -------- A simple arc of angle Pi.  .. manim:: ArcExample     :save_last_frame:      class ArcExample(Scene):         def construct(self):             self.add(Arc(angle=PI))
Arc,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,A circular arc.  Examples -------- A simple arc of angle Pi.  .. manim:: ArcExample     :save_last_frame:      class ArcExample(Scene):         def construct(self):             self.add(Arc(angle=PI))
Arc,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,A circular arc.  Examples -------- A simple arc of angle Pi.  .. manim:: ArcExample     :save_last_frame:      class ArcExample(Scene):         def construct(self):             self.add(Arc(angle=PI))
ArcBetweenPoints,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Inherits from Arc and additionally takes 2 points between which the arc is spanned.  Example ------- .. manim:: ArcBetweenPointsExample    class ArcBetweenPointsExample(Scene):       def construct(self):           circle = Circle(radius=2, stroke_color=GREY)           dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)           dot_1_text = Tex(""(2,0)"").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)           dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)           dot_2_text = Tex(""(0,2)"").scale(0.5).next_to(dot_2, UP).set_color(BLUE)           arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)           self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)           self.play(Create(arc))"
ArcBetweenPoints,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Inherits from Arc and additionally takes 2 points between which the arc is spanned.  Example ------- .. manim:: ArcBetweenPointsExample    class ArcBetweenPointsExample(Scene):       def construct(self):           circle = Circle(radius=2, stroke_color=GREY)           dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)           dot_1_text = Tex(""(2,0)"").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)           dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)           dot_2_text = Tex(""(0,2)"").scale(0.5).next_to(dot_2, UP).set_color(BLUE)           arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)           self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)           self.play(Create(arc))"
ArcBetweenPoints,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Inherits from Arc and additionally takes 2 points between which the arc is spanned.  Example ------- .. manim:: ArcBetweenPointsExample    class ArcBetweenPointsExample(Scene):       def construct(self):           circle = Circle(radius=2, stroke_color=GREY)           dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)           dot_1_text = Tex(""(2,0)"").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)           dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)           dot_2_text = Tex(""(0,2)"").scale(0.5).next_to(dot_2, UP).set_color(BLUE)           arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)           self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)           self.play(Create(arc))"
ArcPolygon,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A generalized polygon allowing for points to be connected with arcs.  This version tries to stick close to the way :class:`Polygon` is used. Points can be passed to it directly which are used to generate the according arcs (using :class:`ArcBetweenPoints`). An angle or radius can be passed to it to use across all arcs, but to configure arcs individually an ``arc_config`` list has to be passed with the syntax explained below.  Parameters ---------- vertices     A list of vertices, start and end points for the arc segments. angle     The angle used for constructing the arcs. If no other parameters     are set, this angle is used to construct all arcs. radius     The circle radius used to construct the arcs. If specified,     overrides the specified ``angle``. arc_config     When passing a ``dict``, its content will be passed as keyword     arguments to :class:`~.ArcBetweenPoints`. Otherwise, a list     of dictionaries containing values that are passed as keyword     arguments for every individual arc can be passed. kwargs     Further keyword arguments that are passed to the constructor of     :class:`~.VMobject`.  Attributes ---------- arcs : :class:`list`     The arcs created from the input parameters::          >>> from manim import ArcPolygon         >>> ap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])         >>> ap.arcs         [ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]   .. tip::      Two instances of :class:`ArcPolygon` can be transformed properly into one     another as well. Be advised that any arc initialized with ``angle=0``     will actually be a straight line, so if a straight section should seamlessly     transform into an arced section or vice versa, initialize the straight section     with a negligible angle instead (such as ``angle=0.0001``).  .. note::     There is an alternative version (:class:`ArcPolygonFromArcs`) that is instantiated     with pre-defined arcs.  See Also -------- :class:`ArcPolygonFromArcs`   Examples -------- .. manim:: SeveralArcPolygons      class SeveralArcPolygons(Scene):         def construct(self):             a = [0, 0, 0]             b = [2, 0, 0]             c = [0, 2, 0]             ap1 = ArcPolygon(a, b, c, radius=2)             ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)             ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})             ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,                                         arc_config=[{'radius': 1.7, 'color': RED},                                         {'angle': 20*DEGREES, 'color': BLUE},                                         {'radius': 1}])             ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()             self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])             self.wait()  For further examples see :class:`ArcPolygonFromArcs`."
ArcPolygonFromArcs,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A generalized polygon allowing for points to be connected with arcs.  This version takes in pre-defined arcs to generate the arcpolygon and introduces little new syntax. However unlike :class:`Polygon` it can't be created with points directly.  For proper appearance the passed arcs should connect seamlessly: ``[a,b][b,c][c,a]``  If there are any gaps between the arcs, those will be filled in with straight lines, which can be used deliberately for any straight sections. Arcs can also be passed as straight lines such as an arc initialized with ``angle=0``.  Parameters ---------- arcs     These are the arcs from which the arcpolygon is assembled. kwargs     Keyword arguments that are passed to the constructor of     :class:`~.VMobject`. Affects how the ArcPolygon itself is drawn,     but doesn't affect passed arcs.  Attributes ---------- arcs     The arcs used to initialize the ArcPolygonFromArcs::          >>> from manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints         >>> ap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())         >>> ap.arcs         [Arc, ArcBetweenPoints, Arc]   .. tip::      Two instances of :class:`ArcPolygon` can be transformed properly into     one another as well. Be advised that any arc initialized with ``angle=0``     will actually be a straight line, so if a straight section should seamlessly     transform into an arced section or vice versa, initialize the straight     section with a negligible angle instead (such as ``angle=0.0001``).  .. note::     There is an alternative version (:class:`ArcPolygon`) that can be instantiated     with points.  .. seealso::     :class:`ArcPolygon`  Examples -------- One example of an arcpolygon is the Reuleaux triangle. Instead of 3 straight lines connecting the outer points, a Reuleaux triangle has 3 arcs connecting those points, making a shape with constant width.  Passed arcs are stored as submobjects in the arcpolygon. This means that the arcs are changed along with the arcpolygon, for example when it's shifted, and these arcs can be manipulated after the arcpolygon has been initialized.  Also both the arcs contained in an :class:`~.ArcPolygonFromArcs`, as well as the arcpolygon itself are drawn, which affects draw time in :class:`~.Create` for example. In most cases the arcs themselves don't need to be drawn, in which case they can be passed as invisible.  .. manim:: ArcPolygonExample      class ArcPolygonExample(Scene):         def construct(self):             arc_conf = {""stroke_width"": 0}             poly_conf = {""stroke_width"": 10, ""stroke_color"": BLUE,                   ""fill_opacity"": 1, ""color"": PURPLE}             a = [-1, 0, 0]             b = [1, 0, 0]             c = [0, np.sqrt(3), 0]             arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)             arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)             arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)             reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)             self.play(FadeIn(reuleaux_tri))             self.wait(2)  The arcpolygon itself can also be hidden so that instead only the contained arcs are drawn. This can be used to easily debug arcs or to highlight them.  .. manim:: ArcPolygonExample2      class ArcPolygonExample2(Scene):         def construct(self):             arc_conf = {""stroke_width"": 3, ""stroke_color"": BLUE,                 ""fill_opacity"": 0.5, ""color"": GREEN}             poly_conf = {""color"": None}             a = [-1, 0, 0]             b = [1, 0, 0]             c = [0, np.sqrt(3), 0]             arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)             arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)             arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)             reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)             self.play(FadeIn(reuleaux_tri))             self.wait(2)"
Circle,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle.  Parameters ---------- color     The color of the shape. kwargs     Additional arguments to be passed to :class:`Arc`  Examples -------- .. manim:: CircleExample     :save_last_frame:      class CircleExample(Scene):         def construct(self):             circle_1 = Circle(radius=1.0)             circle_2 = Circle(radius=1.5, color=GREEN)             circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)              circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)             self.add(circle_group)"
Circle,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle.  Parameters ---------- color     The color of the shape. kwargs     Additional arguments to be passed to :class:`Arc`  Examples -------- .. manim:: CircleExample     :save_last_frame:      class CircleExample(Scene):         def construct(self):             circle_1 = Circle(radius=1.0)             circle_2 = Circle(radius=1.5, color=GREEN)             circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)              circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)             self.add(circle_group)"
Circle,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle.  Parameters ---------- color     The color of the shape. kwargs     Additional arguments to be passed to :class:`Arc`  Examples -------- .. manim:: CircleExample     :save_last_frame:      class CircleExample(Scene):         def construct(self):             circle_1 = Circle(radius=1.0)             circle_2 = Circle(radius=1.5, color=GREEN)             circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)              circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)             self.add(circle_group)"
Circle,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle.  Parameters ---------- color     The color of the shape. kwargs     Additional arguments to be passed to :class:`Arc`  Examples -------- .. manim:: CircleExample     :save_last_frame:      class CircleExample(Scene):         def construct(self):             circle_1 = Circle(radius=1.0)             circle_2 = Circle(radius=1.5, color=GREEN)             circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)              circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)             self.add(circle_group)"
Circle,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle.  Parameters ---------- color     The color of the shape. kwargs     Additional arguments to be passed to :class:`Arc`  Examples -------- .. manim:: CircleExample     :save_last_frame:      class CircleExample(Scene):         def construct(self):             circle_1 = Circle(radius=1.0)             circle_2 = Circle(radius=1.5, color=GREEN)             circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)              circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)             self.add(circle_group)"
Circle,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle.  Parameters ---------- color     The color of the shape. kwargs     Additional arguments to be passed to :class:`Arc`  Examples -------- .. manim:: CircleExample     :save_last_frame:      class CircleExample(Scene):         def construct(self):             circle_1 = Circle(radius=1.0)             circle_2 = Circle(radius=1.5, color=GREEN)             circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)              circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)             self.add(circle_group)"
CubicBezier,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A cubic Bézier curve.  Example ------- .. manim:: BezierSplineExample     :save_last_frame:      class BezierSplineExample(Scene):         def construct(self):             p1 = np.array([-3, 1, 0])             p1b = p1 + [1, 0, 0]             d1 = Dot(point=p1).set_color(BLUE)             l1 = Line(p1, p1b)             p2 = np.array([3, -1, 0])             p2b = p2 - [1, 0, 0]             d2 = Dot(point=p2).set_color(RED)             l2 = Line(p2, p2b)             bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)             self.add(l1, d1, l2, d2, bezier)"
CurvedArrow,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Inherits from Arc and additionally takes 2 points between which the arc is spanned.  Example ------- .. manim:: ArcBetweenPointsExample    class ArcBetweenPointsExample(Scene):       def construct(self):           circle = Circle(radius=2, stroke_color=GREY)           dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)           dot_1_text = Tex(""(2,0)"").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)           dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)           dot_2_text = Tex(""(0,2)"").scale(0.5).next_to(dot_2, UP).set_color(BLUE)           arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)           self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)           self.play(Create(arc))"
CurvedDoubleArrow,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Inherits from Arc and additionally takes 2 points between which the arc is spanned.  Example ------- .. manim:: ArcBetweenPointsExample    class ArcBetweenPointsExample(Scene):       def construct(self):           circle = Circle(radius=2, stroke_color=GREY)           dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)           dot_1_text = Tex(""(2,0)"").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)           dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)           dot_2_text = Tex(""(0,2)"").scale(0.5).next_to(dot_2, UP).set_color(BLUE)           arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)           self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)           self.play(Create(arc))"
Dot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle with a very small radius.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. stroke_width     The thickness of the outline of the dot. fill_opacity     The opacity of the dot's fill_colour color     The color of the dot. kwargs     Additional arguments to be passed to :class:`Circle`  Examples -------- .. manim:: DotExample     :save_last_frame:      class DotExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT, radius=0.08)             dot2 = Dot(point=ORIGIN)             dot3 = Dot(point=RIGHT)             self.add(dot1,dot2,dot3)"
Dot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle with a very small radius.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. stroke_width     The thickness of the outline of the dot. fill_opacity     The opacity of the dot's fill_colour color     The color of the dot. kwargs     Additional arguments to be passed to :class:`Circle`  Examples -------- .. manim:: DotExample     :save_last_frame:      class DotExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT, radius=0.08)             dot2 = Dot(point=ORIGIN)             dot3 = Dot(point=RIGHT)             self.add(dot1,dot2,dot3)"
Dot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle with a very small radius.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. stroke_width     The thickness of the outline of the dot. fill_opacity     The opacity of the dot's fill_colour color     The color of the dot. kwargs     Additional arguments to be passed to :class:`Circle`  Examples -------- .. manim:: DotExample     :save_last_frame:      class DotExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT, radius=0.08)             dot2 = Dot(point=ORIGIN)             dot3 = Dot(point=RIGHT)             self.add(dot1,dot2,dot3)"
Dot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle with a very small radius.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. stroke_width     The thickness of the outline of the dot. fill_opacity     The opacity of the dot's fill_colour color     The color of the dot. kwargs     Additional arguments to be passed to :class:`Circle`  Examples -------- .. manim:: DotExample     :save_last_frame:      class DotExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT, radius=0.08)             dot2 = Dot(point=ORIGIN)             dot3 = Dot(point=RIGHT)             self.add(dot1,dot2,dot3)"
Dot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle with a very small radius.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. stroke_width     The thickness of the outline of the dot. fill_opacity     The opacity of the dot's fill_colour color     The color of the dot. kwargs     Additional arguments to be passed to :class:`Circle`  Examples -------- .. manim:: DotExample     :save_last_frame:      class DotExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT, radius=0.08)             dot2 = Dot(point=ORIGIN)             dot3 = Dot(point=RIGHT)             self.add(dot1,dot2,dot3)"
Dot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circle with a very small radius.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. stroke_width     The thickness of the outline of the dot. fill_opacity     The opacity of the dot's fill_colour color     The color of the dot. kwargs     Additional arguments to be passed to :class:`Circle`  Examples -------- .. manim:: DotExample     :save_last_frame:      class DotExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT, radius=0.08)             dot2 = Dot(point=ORIGIN)             dot3 = Dot(point=RIGHT)             self.add(dot1,dot2,dot3)"
Ellipse,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A circular shape; oval, circle.  Parameters ---------- width    The horizontal width of the ellipse. height    The vertical height of the ellipse. kwargs    Additional arguments to be passed to :class:`Circle`.  Examples -------- .. manim:: EllipseExample     :save_last_frame:      class EllipseExample(Scene):         def construct(self):             ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)             ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)             ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)             self.add(ellipse_group)"
LabeledDot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A :class:`Dot` containing a label in its center.  Parameters ---------- label     The label of the :class:`Dot`. This is rendered as :class:`~.MathTex`     by default (i.e., when passing a :class:`str`), but other classes     representing rendered strings like :class:`~.Text` or :class:`~.Tex`     can be passed as well. radius     The radius of the :class:`Dot`. If ``None`` (the default), the radius     is calculated based on the size of the ``label``.  Examples -------- .. manim:: SeveralLabeledDots     :save_last_frame:      class SeveralLabeledDots(Scene):         def construct(self):             sq = Square(fill_color=RED, fill_opacity=1)             self.add(sq)             dot1 = LabeledDot(Tex(""42"", color=RED))             dot2 = LabeledDot(MathTex(""a"", color=GREEN))             dot3 = LabeledDot(Text(""ii"", color=BLUE))             dot4 = LabeledDot(""3"")             dot1.next_to(sq, UL)             dot2.next_to(sq, UR)             dot3.next_to(sq, DL)             dot4.next_to(sq, DR)             self.add(dot1, dot2, dot3, dot4)"
LabeledDot,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A :class:`Dot` containing a label in its center.  Parameters ---------- label     The label of the :class:`Dot`. This is rendered as :class:`~.MathTex`     by default (i.e., when passing a :class:`str`), but other classes     representing rendered strings like :class:`~.Text` or :class:`~.Tex`     can be passed as well. radius     The radius of the :class:`Dot`. If ``None`` (the default), the radius     is calculated based on the size of the ``label``.  Examples -------- .. manim:: SeveralLabeledDots     :save_last_frame:      class SeveralLabeledDots(Scene):         def construct(self):             sq = Square(fill_color=RED, fill_opacity=1)             self.add(sq)             dot1 = LabeledDot(Tex(""42"", color=RED))             dot2 = LabeledDot(MathTex(""a"", color=GREEN))             dot3 = LabeledDot(Text(""ii"", color=BLUE))             dot4 = LabeledDot(""3"")             dot1.next_to(sq, UL)             dot2.next_to(sq, UR)             dot3.next_to(sq, DL)             dot4.next_to(sq, DR)             self.add(dot1, dot2, dot3, dot4)"
Sector,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"A sector of a circle.  Examples -------- .. manim:: ExampleSector     :save_last_frame:      class ExampleSector(Scene):         def construct(self):             sector = Sector(radius=2)             sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])             sector.set_color(RED)             sector2.set_color(PINK)             self.add(sector, sector2)"
TipableVMobject,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
TipableVMobject,manim.mobject.geometry.arc,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/arc.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Difference,manim.mobject.geometry.boolean_ops,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/boolean_ops.py,"Subtracts one :class:`~.VMobject` from another one.  Parameters ---------- subject     The 1st :class:`~.VMobject`. clip     The 2nd :class:`~.VMobject`  Example ------- .. manim:: DifferenceExample     :save_last_frame:      class DifferenceExample(Scene):         def construct(self):             sq = Square(color=RED, fill_opacity=1)             sq.move_to([-2, 0, 0])             cr = Circle(color=BLUE, fill_opacity=1)             cr.move_to([-1.3, 0.7, 0])             un = Difference(sq, cr, color=GREEN, fill_opacity=1)             un.move_to([1.5, 0, 0])             self.add(sq, cr, un)"
Exclusion,manim.mobject.geometry.boolean_ops,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/boolean_ops.py,"Find the XOR between two :class:`~.VMobject`. This creates a new :class:`~.VMobject` consisting of the region covered by exactly one of them.  Parameters ---------- subject     The 1st :class:`~.VMobject`. clip     The 2nd :class:`~.VMobject`  Example ------- .. manim:: IntersectionExample     :save_last_frame:      class IntersectionExample(Scene):         def construct(self):             sq = Square(color=RED, fill_opacity=1)             sq.move_to([-2, 0, 0])             cr = Circle(color=BLUE, fill_opacity=1)             cr.move_to([-1.3, 0.7, 0])             un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)             un.move_to([1.5, 0.4, 0])             self.add(sq, cr, un)"
Intersection,manim.mobject.geometry.boolean_ops,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/boolean_ops.py,"Find the intersection of two :class:`~.VMobject` s. This keeps the parts covered by both :class:`~.VMobject` s.  Parameters ---------- vmobjects     The :class:`~.VMobject` to find the intersection.  Raises ------ ValueError     If less the 2 :class:`~.VMobject` are passed.  Example ------- .. manim:: IntersectionExample     :save_last_frame:      class IntersectionExample(Scene):         def construct(self):             sq = Square(color=RED, fill_opacity=1)             sq.move_to([-2, 0, 0])             cr = Circle(color=BLUE, fill_opacity=1)             cr.move_to([-1.3, 0.7, 0])             un = Intersection(sq, cr, color=GREEN, fill_opacity=1)             un.move_to([1.5, 0, 0])             self.add(sq, cr, un)"
Union,manim.mobject.geometry.boolean_ops,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/boolean_ops.py,"Union of two or more :class:`~.VMobject` s. This returns the common region of the :class:`~VMobject` s.  Parameters ---------- vmobjects     The :class:`~.VMobject` s to find the union of.  Raises ------ ValueError     If less than 2 :class:`~.VMobject` s are passed.  Example ------- .. manim:: UnionExample     :save_last_frame:      class UnionExample(Scene):         def construct(self):             sq = Square(color=RED, fill_opacity=1)             sq.move_to([-2, 0, 0])             cr = Circle(color=BLUE, fill_opacity=1)             cr.move_to([-1.3, 0.7, 0])             un = Union(sq, cr, color=GREEN, fill_opacity=1)             un.move_to([1.5, 0.3, 0])             self.add(sq, cr, un)"
_BooleanOps,manim.mobject.geometry.boolean_ops,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/boolean_ops.py,This class contains some helper functions which helps to convert to and from skia objects and manim objects (:class:`~.VMobject`).
Label,manim.mobject.geometry.labeled,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/labeled.py,"A Label consisting of text surrounded by a frame.  Parameters ---------- label     Label that will be displayed. label_config     A dictionary containing the configuration for the label.     This is only applied if ``label`` is of type ``str``. box_config     A dictionary containing the configuration for the background box. frame_config      A dictionary containing the configuration for the frame.  Examples -------- .. manim:: LabelExample     :save_last_frame:     :quality: high      class LabelExample(Scene):         def construct(self):             label = Label(                 label=Text('Label Text', font='sans-serif'),                 box_config = {                     ""color"" : BLUE,                     ""fill_opacity"" : 0.75                 }             )             label.scale(3)             self.add(label)"
LabeledArrow,manim.mobject.geometry.labeled,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/labeled.py,"Constructs an arrow containing a label box somewhere along its length. This class inherits its label properties from `LabeledLine`, so the main parameters controlling it are the same.  Parameters ---------- label     Label that will be displayed on the Arrow. label_position     A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5. label_config     A dictionary containing the configuration for the label.     This is only applied if ``label`` is of type ``str``. box_config     A dictionary containing the configuration for the background box. frame_config      A dictionary containing the configuration for the frame.      .. seealso::         :class:`LabeledLine`  Examples -------- .. manim:: LabeledArrowExample     :save_last_frame:     :quality: high      class LabeledArrowExample(Scene):         def construct(self):             l_arrow = LabeledArrow(""0.5"", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)              self.add(l_arrow)"
LabeledLine,manim.mobject.geometry.labeled,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/labeled.py,"Constructs a line containing a label box somewhere along its length.  Parameters ---------- label     Label that will be displayed on the line. label_position     A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5. label_config     A dictionary containing the configuration for the label.     This is only applied if ``label`` is of type ``str``. box_config     A dictionary containing the configuration for the background box. frame_config      A dictionary containing the configuration for the frame.      .. seealso::         :class:`LabeledArrow`  Examples -------- .. manim:: LabeledLineExample     :save_last_frame:     :quality: high      class LabeledLineExample(Scene):         def construct(self):             line = LabeledLine(                 label          = '0.5',                 label_position = 0.8,                 label_config = {                     ""font_size"" : 20                 },                 start=LEFT+DOWN,                 end=RIGHT+UP)              line.set_length(line.get_length() * 2)             self.add(line)"
LabeledPolygram,manim.mobject.geometry.labeled,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/labeled.py,"Constructs a polygram containing a label box at its pole of inaccessibility.  Parameters ---------- vertex_groups     Vertices passed to the :class:`~.Polygram` constructor. label     Label that will be displayed on the Polygram. precision     The precision used by the PolyLabel algorithm. label_config     A dictionary containing the configuration for the label.     This is only applied if ``label`` is of type ``str``. box_config     A dictionary containing the configuration for the background box. frame_config      A dictionary containing the configuration for the frame.      .. note::         The PolyLabel Algorithm expects each vertex group to form a closed ring.         If the input is open, :class:`LabeledPolygram` will attempt to close it.         This may cause the polygon to intersect itself leading to unexpected results.      .. tip::         Make sure the precision corresponds to the scale of your inputs!         For instance, if the bounding box of your polygon stretches from 0 to 10,000, a precision of 1.0 or 10.0 should be sufficient.  Examples -------- .. manim:: LabeledPolygramExample     :save_last_frame:     :quality: high      class LabeledPolygramExample(Scene):         def construct(self):             # Define Rings             ring1 = [                 [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],                 [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],                 [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],                 [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],                 [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]             ]             ring2 = [                 [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],                 [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]             ]             ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]              # Create Polygons (for reference)             p1 = Polygon(*ring1, fill_opacity=0.75)             p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)             p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)              # Create Labeled Polygram             polygram = LabeledPolygram(                 *[ring1, ring2, ring3],                 label=Text('Pole', font='sans-serif'),                 precision=0.01,             )              # Display Circle (for reference)             circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)              self.add(p1, p2, p3)             self.add(polygram)             self.add(circle)  .. manim:: LabeledCountryExample     :save_last_frame:     :quality: high      import requests     import json      class LabeledCountryExample(Scene):         def construct(self):             # Fetch JSON data and process arcs             data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()             arcs, transform = data['arcs'], data['transform']             sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]             ssarcs = sorted(sarcs, key=len, reverse=True)[:1]              # Compute Bounding Box             points = np.concatenate(ssarcs)             mins, maxs = np.min(points, axis=0), np.max(points, axis=0)              # Build Axes             ax = Axes(                 x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,                 y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,                 tips=False             )              # Adjust Coordinates             array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]              # Add Polygram             polygram = LabeledPolygram(                 *array,                 label=Text('USA', font='sans-serif'),                 precision=0.01,                 fill_color=BLUE,                 stroke_width=0,                 fill_opacity=0.75             )              # Display Circle (for reference)             circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)              self.add(ax)             self.add(polygram)             self.add(circle)"
Angle,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"A circular arc or elbow-type mobject representing an angle of two lines.  Parameters ---------- line1 :     The first line. line2 :     The second line. radius :     The radius of the :class:`Arc`. quadrant     A sequence of two :class:`int` numbers determining which of the 4 quadrants should be used.     The first value indicates whether to anchor the arc on the first line closer to the end point (1)     or start point (-1), and the second value functions similarly for the     end (1) or start (-1) of the second line.     Possibilities: (1,1), (-1,1), (1,-1), (-1,-1). other_angle :     Toggles between the two possible angles defined by two points and an arc center. If set to     False (default), the arc will always go counterclockwise from the point on line1 until     the point on line2 is reached. If set to True, the angle will go clockwise from line1 to line2. dot     Allows for a :class:`Dot` in the arc. Mainly used as an convention to indicate a right angle.     The dot can be customized in the next three parameters. dot_radius     The radius of the :class:`Dot`. If not specified otherwise, this radius will be 1/10 of the arc radius. dot_distance     Relative distance from the center to the arc: 0 puts the dot in the center and 1 on the arc itself. dot_color     The color of the :class:`Dot`. elbow     Produces an elbow-type mobject indicating a right angle, see :class:`RightAngle` for more information     and a shorthand. **kwargs     Further keyword arguments that are passed to the constructor of :class:`Arc` or :class:`Elbow`.  Examples -------- The first example shows some right angles with a dot in the middle while the second example shows all 8 possible angles defined by two lines.  .. manim:: RightArcAngleExample     :save_last_frame:      class RightArcAngleExample(Scene):         def construct(self):             line1 = Line( LEFT, RIGHT )             line2 = Line( DOWN, UP )             rightarcangles = [                 Angle(line1, line2, dot=True),                 Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),                 Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),                 Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),             ]             plots = VGroup()             for angle in rightarcangles:                 plot=VGroup(line1.copy(),line2.copy(), angle)                 plots.add(plot)             plots.arrange(buff=1.5)             self.add(plots)  .. manim:: AngleExample     :save_last_frame:      class AngleExample(Scene):         def construct(self):             line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )             line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )             angles = [                 Angle(line1, line2),                 Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),                 Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),                 Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),                 Angle(line1, line2, other_angle=True),                 Angle(line1, line2, radius=0.4, quadrant=(1,-1)),                 Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),                 Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),             ]             plots = VGroup()             for angle in angles:                 plot=VGroup(line1.copy(),line2.copy(), angle)                 plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))             plots.arrange_in_grid(rows=2,buff=1)             self.add(plots)  .. manim:: FilledAngle     :save_last_frame:      class FilledAngle(Scene):         def construct(self):             l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)             l2 = (                 Line(ORIGIN, 2 * UP + RIGHT)                 .set_color(GREEN)                 .rotate(-20 * DEGREES, about_point=ORIGIN)             )             norm = l1.get_length()             a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)             a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)             q1 = a1.points #  save all coordinates of points of angle a1             q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)             pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point             mfill = VMobject().set_color(ORANGE)             mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)             self.add(l1, l2)             self.add(mfill)"
Arrow,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"An arrow.  Parameters ---------- args     Arguments to be passed to :class:`Line`. stroke_width     The thickness of the arrow. Influenced by :attr:`max_stroke_width_to_length_ratio`. buff     The distance of the arrow from its start and end points. max_tip_length_to_length_ratio     :attr:`tip_length` scales with the length of the arrow. Increasing this ratio raises the max value of :attr:`tip_length`. max_stroke_width_to_length_ratio     :attr:`stroke_width` scales with the length of the arrow. Increasing this ratio ratios the max value of :attr:`stroke_width`. kwargs     Additional arguments to be passed to :class:`Line`.   .. seealso::     :class:`ArrowTip`     :class:`CurvedArrow`  Examples -------- .. manim:: ArrowExample     :save_last_frame:      from manim.mobject.geometry.tips import ArrowSquareTip     class ArrowExample(Scene):         def construct(self):             arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)             arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)             g1 = Group(arrow_1, arrow_2)              # the effect of buff             square = Square(color=MAROON_A)             arrow_3 = Arrow(start=LEFT, end=RIGHT)             arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)             g2 = Group(arrow_3, arrow_4, square)              # a shorter arrow has a shorter tip and smaller stroke width             arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)             arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)             g3 = Group(arrow_5, arrow_6)              self.add(Group(g1, g2, g3).arrange(buff=2))   .. manim:: ArrowExample     :save_last_frame:      class ArrowExample(Scene):         def construct(self):             left_group = VGroup()             # As buff increases, the size of the arrow decreases.             for buff in np.arange(0, 2.2, 0.45):                 left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)             # Required to arrange arrows.             left_group.arrange(DOWN)             left_group.move_to(4 * LEFT)              middle_group = VGroup()             # As max_stroke_width_to_length_ratio gets bigger,             # the width of stroke increases.             for i in np.arange(0, 5, 0.5):                 middle_group += Arrow(max_stroke_width_to_length_ratio=i)             middle_group.arrange(DOWN)              UR_group = VGroup()             # As max_tip_length_to_length_ratio increases,             # the length of the tip increases.             for i in np.arange(0, 0.3, 0.1):                 UR_group += Arrow(max_tip_length_to_length_ratio=i)             UR_group.arrange(DOWN)             UR_group.move_to(4 * RIGHT + 2 * UP)              DR_group = VGroup()             DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)             DR_group.arrange(DOWN)             DR_group.move_to(4 * RIGHT + 2 * DOWN)              self.add(left_group, middle_group, UR_group, DR_group)"
Arrow,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"An arrow.  Parameters ---------- args     Arguments to be passed to :class:`Line`. stroke_width     The thickness of the arrow. Influenced by :attr:`max_stroke_width_to_length_ratio`. buff     The distance of the arrow from its start and end points. max_tip_length_to_length_ratio     :attr:`tip_length` scales with the length of the arrow. Increasing this ratio raises the max value of :attr:`tip_length`. max_stroke_width_to_length_ratio     :attr:`stroke_width` scales with the length of the arrow. Increasing this ratio ratios the max value of :attr:`stroke_width`. kwargs     Additional arguments to be passed to :class:`Line`.   .. seealso::     :class:`ArrowTip`     :class:`CurvedArrow`  Examples -------- .. manim:: ArrowExample     :save_last_frame:      from manim.mobject.geometry.tips import ArrowSquareTip     class ArrowExample(Scene):         def construct(self):             arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)             arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)             g1 = Group(arrow_1, arrow_2)              # the effect of buff             square = Square(color=MAROON_A)             arrow_3 = Arrow(start=LEFT, end=RIGHT)             arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)             g2 = Group(arrow_3, arrow_4, square)              # a shorter arrow has a shorter tip and smaller stroke width             arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)             arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)             g3 = Group(arrow_5, arrow_6)              self.add(Group(g1, g2, g3).arrange(buff=2))   .. manim:: ArrowExample     :save_last_frame:      class ArrowExample(Scene):         def construct(self):             left_group = VGroup()             # As buff increases, the size of the arrow decreases.             for buff in np.arange(0, 2.2, 0.45):                 left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)             # Required to arrange arrows.             left_group.arrange(DOWN)             left_group.move_to(4 * LEFT)              middle_group = VGroup()             # As max_stroke_width_to_length_ratio gets bigger,             # the width of stroke increases.             for i in np.arange(0, 5, 0.5):                 middle_group += Arrow(max_stroke_width_to_length_ratio=i)             middle_group.arrange(DOWN)              UR_group = VGroup()             # As max_tip_length_to_length_ratio increases,             # the length of the tip increases.             for i in np.arange(0, 0.3, 0.1):                 UR_group += Arrow(max_tip_length_to_length_ratio=i)             UR_group.arrange(DOWN)             UR_group.move_to(4 * RIGHT + 2 * UP)              DR_group = VGroup()             DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)             DR_group.arrange(DOWN)             DR_group.move_to(4 * RIGHT + 2 * DOWN)              self.add(left_group, middle_group, UR_group, DR_group)"
Arrow,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"An arrow.  Parameters ---------- args     Arguments to be passed to :class:`Line`. stroke_width     The thickness of the arrow. Influenced by :attr:`max_stroke_width_to_length_ratio`. buff     The distance of the arrow from its start and end points. max_tip_length_to_length_ratio     :attr:`tip_length` scales with the length of the arrow. Increasing this ratio raises the max value of :attr:`tip_length`. max_stroke_width_to_length_ratio     :attr:`stroke_width` scales with the length of the arrow. Increasing this ratio ratios the max value of :attr:`stroke_width`. kwargs     Additional arguments to be passed to :class:`Line`.   .. seealso::     :class:`ArrowTip`     :class:`CurvedArrow`  Examples -------- .. manim:: ArrowExample     :save_last_frame:      from manim.mobject.geometry.tips import ArrowSquareTip     class ArrowExample(Scene):         def construct(self):             arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)             arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)             g1 = Group(arrow_1, arrow_2)              # the effect of buff             square = Square(color=MAROON_A)             arrow_3 = Arrow(start=LEFT, end=RIGHT)             arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)             g2 = Group(arrow_3, arrow_4, square)              # a shorter arrow has a shorter tip and smaller stroke width             arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)             arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)             g3 = Group(arrow_5, arrow_6)              self.add(Group(g1, g2, g3).arrange(buff=2))   .. manim:: ArrowExample     :save_last_frame:      class ArrowExample(Scene):         def construct(self):             left_group = VGroup()             # As buff increases, the size of the arrow decreases.             for buff in np.arange(0, 2.2, 0.45):                 left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)             # Required to arrange arrows.             left_group.arrange(DOWN)             left_group.move_to(4 * LEFT)              middle_group = VGroup()             # As max_stroke_width_to_length_ratio gets bigger,             # the width of stroke increases.             for i in np.arange(0, 5, 0.5):                 middle_group += Arrow(max_stroke_width_to_length_ratio=i)             middle_group.arrange(DOWN)              UR_group = VGroup()             # As max_tip_length_to_length_ratio increases,             # the length of the tip increases.             for i in np.arange(0, 0.3, 0.1):                 UR_group += Arrow(max_tip_length_to_length_ratio=i)             UR_group.arrange(DOWN)             UR_group.move_to(4 * RIGHT + 2 * UP)              DR_group = VGroup()             DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)             DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)             DR_group.arrange(DOWN)             DR_group.move_to(4 * RIGHT + 2 * DOWN)              self.add(left_group, middle_group, UR_group, DR_group)"
DashedLine,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"A dashed :class:`Line`.  Parameters ---------- args     Arguments to be passed to :class:`Line` dash_length     The length of each individual dash of the line. dashed_ratio     The ratio of dash space to empty space. Range of 0-1. kwargs     Additional arguments to be passed to :class:`Line`   .. seealso::     :class:`~.DashedVMobject`  Examples -------- .. manim:: DashedLineExample     :save_last_frame:      class DashedLineExample(Scene):         def construct(self):             # dash_length increased             dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)             # normal             dashed_2 = DashedLine(config.left_side, config.right_side)             # dashed_ratio decreased             dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)             self.add(dashed_1, dashed_2, dashed_3)"
DashedLine,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"A dashed :class:`Line`.  Parameters ---------- args     Arguments to be passed to :class:`Line` dash_length     The length of each individual dash of the line. dashed_ratio     The ratio of dash space to empty space. Range of 0-1. kwargs     Additional arguments to be passed to :class:`Line`   .. seealso::     :class:`~.DashedVMobject`  Examples -------- .. manim:: DashedLineExample     :save_last_frame:      class DashedLineExample(Scene):         def construct(self):             # dash_length increased             dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)             # normal             dashed_2 = DashedLine(config.left_side, config.right_side)             # dashed_ratio decreased             dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)             self.add(dashed_1, dashed_2, dashed_3)"
DoubleArrow,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"An arrow with tips on both ends.  Parameters ---------- args     Arguments to be passed to :class:`Arrow` kwargs     Additional arguments to be passed to :class:`Arrow`   .. seealso::     :class:`.~ArrowTip`     :class:`.~CurvedDoubleArrow`  Examples -------- .. manim:: DoubleArrowExample     :save_last_frame:      from manim.mobject.geometry.tips import ArrowCircleFilledTip     class DoubleArrowExample(Scene):         def construct(self):             circle = Circle(radius=2.0)             d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())             d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)             group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)             self.add(group)   .. manim:: DoubleArrowExample2     :save_last_frame:      class DoubleArrowExample2(Scene):         def construct(self):             box = Square()             p1 = box.get_left()             p2 = box.get_right()             d1 = DoubleArrow(p1, p2, buff=0)             d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)             d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)             Group(d1, d2, d3).arrange(DOWN)             self.add(box, d1, d2, d3)"
Elbow,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Two lines that create a right angle about each other: L-shape.  Parameters ---------- width     The length of the elbow's sides. angle     The rotation of the elbow. kwargs     Additional arguments to be passed to :class:`~.VMobject`  .. seealso::     :class:`RightAngle`  Examples -------- .. manim:: ElbowExample     :save_last_frame:      class ElbowExample(Scene):         def construct(self):             elbow_1 = Elbow()             elbow_2 = Elbow(width=2.0)             elbow_3 = Elbow(width=2.0, angle=5*PI/4)              elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)             self.add(elbow_group)"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
Line,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Meant for shared functionality between Arc and Line. Functionality can be classified broadly into these groups:      * Adding, Creating, Modifying tips         - add_tip calls create_tip, before pushing the new tip             into the TipableVMobject's list of submobjects         - stylistic and positional configuration      * Checking for tips         - Boolean checks for whether the TipableVMobject has a tip             and a starting tip      * Getters         - Straightforward accessors, returning information pertaining             to the TipableVMobject instance's tip(s), its length etc"
RightAngle,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"An elbow-type mobject representing a right angle between two lines.  Parameters ---------- line1     The first line. line2     The second line. length     The length of the arms. **kwargs     Further keyword arguments that are passed to the constructor of :class:`Angle`.  Examples -------- .. manim:: RightAngleExample     :save_last_frame:      class RightAngleExample(Scene):         def construct(self):             line1 = Line( LEFT, RIGHT )             line2 = Line( DOWN, UP )             rightangles = [                 RightAngle(line1, line2),                 RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),                 RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),                 RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),             ]             plots = VGroup()             for rightangle in rightangles:                 plot=VGroup(line1.copy(),line2.copy(), rightangle)                 plots.add(plot)             plots.arrange(buff=1.5)             self.add(plots)"
TangentLine,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"Constructs a line tangent to a :class:`~.VMobject` at a specific point.  Parameters ---------- vmob     The VMobject on which the tangent line is drawn. alpha     How far along the shape that the line will be constructed. range: 0-1. length     Length of the tangent line. d_alpha     The ``dx`` value kwargs     Additional arguments to be passed to :class:`Line`   .. seealso::     :meth:`~.VMobject.point_from_proportion`  Examples -------- .. manim:: TangentLineExample     :save_last_frame:      class TangentLineExample(Scene):         def construct(self):             circle = Circle(radius=2)             line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right             line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left             self.add(circle, line_1, line_2)"
Vector,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"A vector specialized for use in graphs.  .. caution::     Do not confuse with the :class:`~.Vector2D`,     :class:`~.Vector3D` or :class:`~.VectorND` type aliases,     which are not Mobjects!  Parameters ---------- direction     The direction of the arrow. buff      The distance of the vector from its endpoints. kwargs     Additional arguments to be passed to :class:`Arrow`  Examples -------- .. manim:: VectorExample     :save_last_frame:      class VectorExample(Scene):         def construct(self):             plane = NumberPlane()             vector_1 = Vector([1,2])             vector_2 = Vector([-5,-2])             self.add(plane, vector_1, vector_2)"
Vector,manim.mobject.geometry.line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/line.py,"A vector specialized for use in graphs.  .. caution::     Do not confuse with the :class:`~.Vector2D`,     :class:`~.Vector3D` or :class:`~.VectorND` type aliases,     which are not Mobjects!  Parameters ---------- direction     The direction of the arrow. buff      The distance of the vector from its endpoints. kwargs     Additional arguments to be passed to :class:`Arrow`  Examples -------- .. manim:: VectorExample     :save_last_frame:      class VectorExample(Scene):         def construct(self):             plane = NumberPlane()             vector_1 = Vector([1,2])             vector_2 = Vector([-5,-2])             self.add(plane, vector_1, vector_2)"
ConvexHull,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"Constructs a convex hull for a set of points in no particular order.  Parameters ---------- points     The points to consider. tolerance     The tolerance used by quickhull. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: ConvexHullExample     :save_last_frame:     :quality: high      class ConvexHullExample(Scene):         def construct(self):             points = [                 [-2.35, -2.25, 0],                 [1.65, -2.25, 0],                 [2.65, -0.25, 0],                 [1.65, 1.75, 0],                 [-0.35, 2.75, 0],                 [-2.35, 0.75, 0],                 [-0.35, -1.25, 0],                 [0.65, -0.25, 0],                 [-1.35, 0.25, 0],                 [0.15, 0.75, 0]             ]             hull = ConvexHull(*points, color=BLUE)             dots = VGroup(*[Dot(point) for point in points])             self.add(hull)             self.add(dots)"
Cutout,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A shape with smaller cutouts.  Parameters ---------- main_shape     The primary shape from which cutouts are made. mobjects     The smaller shapes which are to be cut out of the ``main_shape``. kwargs     Further keyword arguments that are passed to the constructor of     :class:`~.VMobject`.   .. warning::     Technically, this class behaves similar to a symmetric difference: if     parts of the ``mobjects`` are not located within the ``main_shape``,     these parts will be added to the resulting :class:`~.VMobject`.  Examples -------- .. manim:: CutoutExample      class CutoutExample(Scene):         def construct(self):             s1 = Square().scale(2.5)             s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)             s3 = Square().shift(UP + RIGHT).scale(0.5)             s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)             s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)             c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)             self.play(Write(c), run_time=4)             self.wait()"
Polygon,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A shape consisting of one closed loop of vertices.  Parameters ---------- vertices     The vertices of the :class:`Polygon`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: PolygonExample     :save_last_frame:      class PolygonExample(Scene):         def construct(self):             isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])             position_list = [                 [4, 1, 0],  # middle right                 [4, -2.5, 0],  # bottom right                 [0, -2.5, 0],  # bottom left                 [0, 3, 0],  # top left                 [2, 1, 0],  # middle                 [4, 3, 0],  # top right             ]             square_and_triangles = Polygon(*position_list, color=PURPLE_B)             self.add(isosceles, square_and_triangles)"
Polygon,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A shape consisting of one closed loop of vertices.  Parameters ---------- vertices     The vertices of the :class:`Polygon`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: PolygonExample     :save_last_frame:      class PolygonExample(Scene):         def construct(self):             isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])             position_list = [                 [4, 1, 0],  # middle right                 [4, -2.5, 0],  # bottom right                 [0, -2.5, 0],  # bottom left                 [0, 3, 0],  # top left                 [2, 1, 0],  # middle                 [4, 3, 0],  # top right             ]             square_and_triangles = Polygon(*position_list, color=PURPLE_B)             self.add(isosceles, square_and_triangles)"
Polygon,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A shape consisting of one closed loop of vertices.  Parameters ---------- vertices     The vertices of the :class:`Polygon`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: PolygonExample     :save_last_frame:      class PolygonExample(Scene):         def construct(self):             isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])             position_list = [                 [4, 1, 0],  # middle right                 [4, -2.5, 0],  # bottom right                 [0, -2.5, 0],  # bottom left                 [0, 3, 0],  # top left                 [2, 1, 0],  # middle                 [4, 3, 0],  # top right             ]             square_and_triangles = Polygon(*position_list, color=PURPLE_B)             self.add(isosceles, square_and_triangles)"
Polygon,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A shape consisting of one closed loop of vertices.  Parameters ---------- vertices     The vertices of the :class:`Polygon`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: PolygonExample     :save_last_frame:      class PolygonExample(Scene):         def construct(self):             isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])             position_list = [                 [4, 1, 0],  # middle right                 [4, -2.5, 0],  # bottom right                 [0, -2.5, 0],  # bottom left                 [0, 3, 0],  # top left                 [2, 1, 0],  # middle                 [4, 3, 0],  # top right             ]             square_and_triangles = Polygon(*position_list, color=PURPLE_B)             self.add(isosceles, square_and_triangles)"
Polygon,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A shape consisting of one closed loop of vertices.  Parameters ---------- vertices     The vertices of the :class:`Polygon`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: PolygonExample     :save_last_frame:      class PolygonExample(Scene):         def construct(self):             isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])             position_list = [                 [4, 1, 0],  # middle right                 [4, -2.5, 0],  # bottom right                 [0, -2.5, 0],  # bottom left                 [0, 3, 0],  # top left                 [2, 1, 0],  # middle                 [4, 3, 0],  # top right             ]             square_and_triangles = Polygon(*position_list, color=PURPLE_B)             self.add(isosceles, square_and_triangles)"
Polygram,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A generalized :class:`Polygon`, allowing for disconnected sets of edges.  Parameters ---------- vertex_groups     The groups of vertices making up the :class:`Polygram`.      The first vertex in each group is repeated to close the shape.     Each point must be 3-dimensional: ``[x,y,z]`` color     The color of the :class:`Polygram`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: PolygramExample      import numpy as np      class PolygramExample(Scene):         def construct(self):             hexagram = Polygram(                 [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],                 [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],             )             self.add(hexagram)              dot = Dot()             self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)             self.remove(dot)             self.wait()"
Polygram,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A generalized :class:`Polygon`, allowing for disconnected sets of edges.  Parameters ---------- vertex_groups     The groups of vertices making up the :class:`Polygram`.      The first vertex in each group is repeated to close the shape.     Each point must be 3-dimensional: ``[x,y,z]`` color     The color of the :class:`Polygram`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: PolygramExample      import numpy as np      class PolygramExample(Scene):         def construct(self):             hexagram = Polygram(                 [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],                 [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],             )             self.add(hexagram)              dot = Dot()             self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)             self.remove(dot)             self.wait()"
Rectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A quadrilateral with two sets of parallel sides.  Parameters ---------- color     The color of the rectangle. height     The vertical height of the rectangle. width     The horizontal width of the rectangle. grid_xstep     Space between vertical grid lines. grid_ystep     Space between horizontal grid lines. mark_paths_closed     No purpose. close_new_points     No purpose. kwargs     Additional arguments to be passed to :class:`Polygon`  Examples ---------- .. manim:: RectangleExample     :save_last_frame:      class RectangleExample(Scene):         def construct(self):             rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)             rect2 = Rectangle(width=1.0, height=4.0)             rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)             rect3.grid_lines.set_stroke(width=1)              rects = Group(rect1, rect2, rect3).arrange(buff=1)             self.add(rects)"
Rectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A quadrilateral with two sets of parallel sides.  Parameters ---------- color     The color of the rectangle. height     The vertical height of the rectangle. width     The horizontal width of the rectangle. grid_xstep     Space between vertical grid lines. grid_ystep     Space between horizontal grid lines. mark_paths_closed     No purpose. close_new_points     No purpose. kwargs     Additional arguments to be passed to :class:`Polygon`  Examples ---------- .. manim:: RectangleExample     :save_last_frame:      class RectangleExample(Scene):         def construct(self):             rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)             rect2 = Rectangle(width=1.0, height=4.0)             rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)             rect3.grid_lines.set_stroke(width=1)              rects = Group(rect1, rect2, rect3).arrange(buff=1)             self.add(rects)"
Rectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A quadrilateral with two sets of parallel sides.  Parameters ---------- color     The color of the rectangle. height     The vertical height of the rectangle. width     The horizontal width of the rectangle. grid_xstep     Space between vertical grid lines. grid_ystep     Space between horizontal grid lines. mark_paths_closed     No purpose. close_new_points     No purpose. kwargs     Additional arguments to be passed to :class:`Polygon`  Examples ---------- .. manim:: RectangleExample     :save_last_frame:      class RectangleExample(Scene):         def construct(self):             rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)             rect2 = Rectangle(width=1.0, height=4.0)             rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)             rect3.grid_lines.set_stroke(width=1)              rects = Group(rect1, rect2, rect3).arrange(buff=1)             self.add(rects)"
Rectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A quadrilateral with two sets of parallel sides.  Parameters ---------- color     The color of the rectangle. height     The vertical height of the rectangle. width     The horizontal width of the rectangle. grid_xstep     Space between vertical grid lines. grid_ystep     Space between horizontal grid lines. mark_paths_closed     No purpose. close_new_points     No purpose. kwargs     Additional arguments to be passed to :class:`Polygon`  Examples ---------- .. manim:: RectangleExample     :save_last_frame:      class RectangleExample(Scene):         def construct(self):             rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)             rect2 = Rectangle(width=1.0, height=4.0)             rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)             rect3.grid_lines.set_stroke(width=1)              rects = Group(rect1, rect2, rect3).arrange(buff=1)             self.add(rects)"
Rectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A quadrilateral with two sets of parallel sides.  Parameters ---------- color     The color of the rectangle. height     The vertical height of the rectangle. width     The horizontal width of the rectangle. grid_xstep     Space between vertical grid lines. grid_ystep     Space between horizontal grid lines. mark_paths_closed     No purpose. close_new_points     No purpose. kwargs     Additional arguments to be passed to :class:`Polygon`  Examples ---------- .. manim:: RectangleExample     :save_last_frame:      class RectangleExample(Scene):         def construct(self):             rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)             rect2 = Rectangle(width=1.0, height=4.0)             rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)             rect3.grid_lines.set_stroke(width=1)              rects = Group(rect1, rect2, rect3).arrange(buff=1)             self.add(rects)"
RegularPolygon,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"An n-sided regular :class:`Polygon`.  Parameters ---------- n     The number of sides of the :class:`RegularPolygon`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: RegularPolygonExample     :save_last_frame:      class RegularPolygonExample(Scene):         def construct(self):             poly_1 = RegularPolygon(n=6)             poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)             poly_3 = RegularPolygon(n=10, color=RED)              poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)             self.add(poly_group)"
RegularPolygon,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"An n-sided regular :class:`Polygon`.  Parameters ---------- n     The number of sides of the :class:`RegularPolygon`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: RegularPolygonExample     :save_last_frame:      class RegularPolygonExample(Scene):         def construct(self):             poly_1 = RegularPolygon(n=6)             poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)             poly_3 = RegularPolygon(n=10, color=RED)              poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)             self.add(poly_group)"
RegularPolygram,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A :class:`Polygram` with regularly spaced vertices.  Parameters ---------- num_vertices     The number of vertices. density     The density of the :class:`RegularPolygram`.      Can be thought of as how many vertices to hop     to draw a line between them. Every ``density``-th     vertex is connected. radius     The radius of the circle that the vertices are placed on. start_angle     The angle the vertices start at; the rotation of     the :class:`RegularPolygram`. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: RegularPolygramExample     :save_last_frame:      class RegularPolygramExample(Scene):         def construct(self):             pentagram = RegularPolygram(5, radius=2)             self.add(pentagram)"
RoundedRectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A rectangle with rounded corners.  Parameters ---------- corner_radius     The curvature of the corners of the rectangle. kwargs     Additional arguments to be passed to :class:`Rectangle`  Examples -------- .. manim:: RoundedRectangleExample     :save_last_frame:      class RoundedRectangleExample(Scene):         def construct(self):             rect_1 = RoundedRectangle(corner_radius=0.5)             rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)              rect_group = Group(rect_1, rect_2).arrange(buff=1)             self.add(rect_group)"
RoundedRectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A rectangle with rounded corners.  Parameters ---------- corner_radius     The curvature of the corners of the rectangle. kwargs     Additional arguments to be passed to :class:`Rectangle`  Examples -------- .. manim:: RoundedRectangleExample     :save_last_frame:      class RoundedRectangleExample(Scene):         def construct(self):             rect_1 = RoundedRectangle(corner_radius=0.5)             rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)              rect_group = Group(rect_1, rect_2).arrange(buff=1)             self.add(rect_group)"
RoundedRectangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A rectangle with rounded corners.  Parameters ---------- corner_radius     The curvature of the corners of the rectangle. kwargs     Additional arguments to be passed to :class:`Rectangle`  Examples -------- .. manim:: RoundedRectangleExample     :save_last_frame:      class RoundedRectangleExample(Scene):         def construct(self):             rect_1 = RoundedRectangle(corner_radius=0.5)             rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)              rect_group = Group(rect_1, rect_2).arrange(buff=1)             self.add(rect_group)"
Square,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A rectangle with equal side lengths.  Parameters ---------- side_length     The length of the sides of the square. kwargs     Additional arguments to be passed to :class:`Rectangle`.  Examples -------- .. manim:: SquareExample     :save_last_frame:      class SquareExample(Scene):         def construct(self):             square_1 = Square(side_length=2.0).shift(DOWN)             square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)             square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)             self.add(square_1, square_2, square_3)"
Square,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A rectangle with equal side lengths.  Parameters ---------- side_length     The length of the sides of the square. kwargs     Additional arguments to be passed to :class:`Rectangle`.  Examples -------- .. manim:: SquareExample     :save_last_frame:      class SquareExample(Scene):         def construct(self):             square_1 = Square(side_length=2.0).shift(DOWN)             square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)             square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)             self.add(square_1, square_2, square_3)"
Square,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A rectangle with equal side lengths.  Parameters ---------- side_length     The length of the sides of the square. kwargs     Additional arguments to be passed to :class:`Rectangle`.  Examples -------- .. manim:: SquareExample     :save_last_frame:      class SquareExample(Scene):         def construct(self):             square_1 = Square(side_length=2.0).shift(DOWN)             square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)             square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)             self.add(square_1, square_2, square_3)"
Square,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A rectangle with equal side lengths.  Parameters ---------- side_length     The length of the sides of the square. kwargs     Additional arguments to be passed to :class:`Rectangle`.  Examples -------- .. manim:: SquareExample     :save_last_frame:      class SquareExample(Scene):         def construct(self):             square_1 = Square(side_length=2.0).shift(DOWN)             square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)             square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)             self.add(square_1, square_2, square_3)"
Star,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"A regular polygram without the intersecting lines.  Parameters ---------- n     How many points on the :class:`Star`. outer_radius     The radius of the circle that the outer vertices are placed on. inner_radius     The radius of the circle that the inner vertices are placed on.      If unspecified, the inner radius will be     calculated such that the edges of the :class:`Star`     perfectly follow the edges of its :class:`RegularPolygram`     counterpart. density     The density of the :class:`Star`. Only used if     ``inner_radius`` is unspecified.      See :class:`RegularPolygram` for more information. start_angle     The angle the vertices start at; the rotation of     the :class:`Star`. kwargs     Forwardeds to the parent constructor.  Raises ------ :exc:`ValueError`     If ``inner_radius`` is unspecified and ``density``     is not in the range ``[1, n/2)``.  Examples -------- .. manim:: StarExample      class StarExample(Scene):         def construct(self):             pentagram = RegularPolygram(5, radius=2)             star = Star(outer_radius=2, color=RED)              self.add(pentagram)             self.play(Create(star), run_time=3)             self.play(FadeOut(star), run_time=2)  .. manim:: DifferentDensitiesExample     :save_last_frame:      class DifferentDensitiesExample(Scene):         def construct(self):             density_2 = Star(7, outer_radius=2, density=2, color=RED)             density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)              self.add(VGroup(density_2, density_3).arrange(RIGHT))"
Triangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"An equilateral triangle.  Parameters ---------- kwargs     Additional arguments to be passed to :class:`RegularPolygon`  Examples -------- .. manim:: TriangleExample     :save_last_frame:      class TriangleExample(Scene):         def construct(self):             triangle_1 = Triangle()             triangle_2 = Triangle().scale(2).rotate(60*DEGREES)             tri_group = Group(triangle_1, triangle_2).arrange(buff=1)             self.add(tri_group)"
Triangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"An equilateral triangle.  Parameters ---------- kwargs     Additional arguments to be passed to :class:`RegularPolygon`  Examples -------- .. manim:: TriangleExample     :save_last_frame:      class TriangleExample(Scene):         def construct(self):             triangle_1 = Triangle()             triangle_2 = Triangle().scale(2).rotate(60*DEGREES)             tri_group = Group(triangle_1, triangle_2).arrange(buff=1)             self.add(tri_group)"
Triangle,manim.mobject.geometry.polygram,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/polygram.py,"An equilateral triangle.  Parameters ---------- kwargs     Additional arguments to be passed to :class:`RegularPolygon`  Examples -------- .. manim:: TriangleExample     :save_last_frame:      class TriangleExample(Scene):         def construct(self):             triangle_1 = Triangle()             triangle_2 = Triangle().scale(2).rotate(60*DEGREES)             tri_group = Group(triangle_1, triangle_2).arrange(buff=1)             self.add(tri_group)"
BackgroundRectangle,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"A background rectangle. Its default color is the background color of the scene.  Examples -------- .. manim:: ExampleBackgroundRectangle     :save_last_frame:      class ExampleBackgroundRectangle(Scene):         def construct(self):             circle = Circle().shift(LEFT)             circle.set_stroke(color=GREEN, width=20)             triangle = Triangle().shift(2 * RIGHT)             triangle.set_fill(PINK, opacity=0.5)             backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)             backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)             self.add(backgroundRectangle1)             self.add(backgroundRectangle2)             self.add(circle)             self.add(triangle)             self.play(Rotate(backgroundRectangle1, PI / 4))             self.play(Rotate(backgroundRectangle2, PI / 2))"
BackgroundRectangle,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"A background rectangle. Its default color is the background color of the scene.  Examples -------- .. manim:: ExampleBackgroundRectangle     :save_last_frame:      class ExampleBackgroundRectangle(Scene):         def construct(self):             circle = Circle().shift(LEFT)             circle.set_stroke(color=GREEN, width=20)             triangle = Triangle().shift(2 * RIGHT)             triangle.set_fill(PINK, opacity=0.5)             backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)             backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)             self.add(backgroundRectangle1)             self.add(backgroundRectangle2)             self.add(circle)             self.add(triangle)             self.play(Rotate(backgroundRectangle1, PI / 4))             self.play(Rotate(backgroundRectangle2, PI / 2))"
BackgroundRectangle,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"A background rectangle. Its default color is the background color of the scene.  Examples -------- .. manim:: ExampleBackgroundRectangle     :save_last_frame:      class ExampleBackgroundRectangle(Scene):         def construct(self):             circle = Circle().shift(LEFT)             circle.set_stroke(color=GREEN, width=20)             triangle = Triangle().shift(2 * RIGHT)             triangle.set_fill(PINK, opacity=0.5)             backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)             backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)             self.add(backgroundRectangle1)             self.add(backgroundRectangle2)             self.add(circle)             self.add(triangle)             self.play(Rotate(backgroundRectangle1, PI / 4))             self.play(Rotate(backgroundRectangle2, PI / 2))"
Cross,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,Creates a cross.  Parameters ---------- mobject     The mobject linked to this instance. It fits the mobject when specified. Defaults to None. stroke_color     Specifies the color of the cross lines. Defaults to RED. stroke_width     Specifies the width of the cross lines. Defaults to 6. scale_factor     Scales the cross to the provided units. Defaults to 1.  Examples -------- .. manim:: ExampleCross     :save_last_frame:      class ExampleCross(Scene):         def construct(self):             cross = Cross()             self.add(cross)
SurroundingRectangle,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"A rectangle surrounding a :class:`~.Mobject`  Examples -------- .. manim:: SurroundingRectExample     :save_last_frame:      class SurroundingRectExample(Scene):         def construct(self):             title = Title(""A Quote from Newton"")             quote = Text(                 ""If I have seen further than others, \n""                 ""it is by standing upon the shoulders of giants."",                 color=BLUE,             ).scale(0.75)             box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)              t2 = Tex(r""Hello World"").scale(1.5)             box2 = SurroundingRectangle(t2, corner_radius=0.2)             mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)             self.add(title, mobjects)"
SurroundingRectangle,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"A rectangle surrounding a :class:`~.Mobject`  Examples -------- .. manim:: SurroundingRectExample     :save_last_frame:      class SurroundingRectExample(Scene):         def construct(self):             title = Title(""A Quote from Newton"")             quote = Text(                 ""If I have seen further than others, \n""                 ""it is by standing upon the shoulders of giants."",                 color=BLUE,             ).scale(0.75)             box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)              t2 = Tex(r""Hello World"").scale(1.5)             box2 = SurroundingRectangle(t2, corner_radius=0.2)             mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)             self.add(title, mobjects)"
SurroundingRectangle,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"A rectangle surrounding a :class:`~.Mobject`  Examples -------- .. manim:: SurroundingRectExample     :save_last_frame:      class SurroundingRectExample(Scene):         def construct(self):             title = Title(""A Quote from Newton"")             quote = Text(                 ""If I have seen further than others, \n""                 ""it is by standing upon the shoulders of giants."",                 color=BLUE,             ).scale(0.75)             box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)              t2 = Tex(r""Hello World"").scale(1.5)             box2 = SurroundingRectangle(t2, corner_radius=0.2)             mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)             self.add(title, mobjects)"
SurroundingRectangle,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"A rectangle surrounding a :class:`~.Mobject`  Examples -------- .. manim:: SurroundingRectExample     :save_last_frame:      class SurroundingRectExample(Scene):         def construct(self):             title = Title(""A Quote from Newton"")             quote = Text(                 ""If I have seen further than others, \n""                 ""it is by standing upon the shoulders of giants."",                 color=BLUE,             ).scale(0.75)             box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)              t2 = Tex(r""Hello World"").scale(1.5)             box2 = SurroundingRectangle(t2, corner_radius=0.2)             mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)             self.add(title, mobjects)"
Underline,manim.mobject.geometry.shape_matchers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/shape_matchers.py,"Creates an underline.  Examples -------- .. manim:: UnderLine     :save_last_frame:      class UnderLine(Scene):         def construct(self):             man = Tex(""Manim"")  # Full Word             ul = Underline(man)  # Underlining the word             self.add(man, ul)"
ArrowCircleFilledTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,Circular arrow tip with filled tip.
ArrowCircleTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,Circular arrow tip.
ArrowSquareFilledTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,Square arrow tip with filled tip.
ArrowSquareTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,Square arrow tip.
ArrowTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,"Base class for arrow tips.  .. seealso::     :class:`ArrowTriangleTip`     :class:`ArrowTriangleFilledTip`     :class:`ArrowCircleTip`     :class:`ArrowCircleFilledTip`     :class:`ArrowSquareTip`     :class:`ArrowSquareFilledTip`     :class:`StealthTip`  Examples -------- Cannot be used directly, only intended for inheritance::      >>> tip = ArrowTip()     Traceback (most recent call last):     ...     NotImplementedError: Has to be implemented in inheriting subclasses.  Instead, use one of the pre-defined ones, or make a custom one like this:  .. manim:: CustomTipExample      >>> from manim import RegularPolygon, Arrow     >>> class MyCustomArrowTip(ArrowTip, RegularPolygon):     ...     def __init__(self, length=0.35, **kwargs):     ...         RegularPolygon.__init__(self, n=5, **kwargs)     ...         self.width = length     ...         self.stretch_to_fit_height(length)     >>> arr = Arrow(     ...     np.array([-2, -2, 0]), np.array([2, 2, 0]), tip_shape=MyCustomArrowTip     ... )     >>> isinstance(arr.tip, RegularPolygon)     True     >>> from manim import Scene, Create     >>> class CustomTipExample(Scene):     ...     def construct(self):     ...         self.play(Create(arr))  Using a class inherited from :class:`ArrowTip` to get a non-filled tip is a shorthand to manually specifying the arrow tip style as follows::      >>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]),     ...               tip_style={'fill_opacity': 0, 'stroke_width': 3})  The following example illustrates the usage of all of the predefined arrow tips.  .. manim:: ArrowTipsShowcase     :save_last_frame:      class ArrowTipsShowcase(Scene):         def construct(self):             tip_names = [                 'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',                 'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'             ]              big_arrows = [                 Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),                 Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),                 Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),                 Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),                  Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),                 Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),                 Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),                 Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)             ]              small_arrows = (                 arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows             )              labels = (                 Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))             )              self.add(*big_arrows, *small_arrows, *labels)"
ArrowTriangleFilledTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,Triangular arrow tip with filled tip.  This is the default arrow tip shape.
ArrowTriangleFilledTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,Triangular arrow tip with filled tip.  This is the default arrow tip shape.
ArrowTriangleTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,Triangular arrow tip.
StealthTip,manim.mobject.geometry.tips,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/geometry/tips.py,'Stealth' fighter / kite arrow shape.  Naming is inspired by the corresponding `TikZ arrow shape <https://tikz.dev/tikz-arrows#sec-16.3>`__.
DiGraph,manim.mobject.graph,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graph.py,"A directed graph.  .. note::      In contrast to undirected graphs, the order in which vertices in a given     edge are specified is relevant here.  See also --------  :class:`.GenericGraph`  Parameters ----------  vertices     A list of vertices. Must be hashable elements. edges     A list of edges, specified as tuples ``(u, v)`` where both ``u``     and ``v`` are vertices. The edge is directed from ``u`` to ``v``. labels     Controls whether or not vertices are labeled. If ``False`` (the default),     the vertices are not labeled; if ``True`` they are labeled using their     names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,     custom labels can be specified by passing a dictionary whose keys are     the vertices, and whose values are the corresponding vertex labels     (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`). label_fill_color     Sets the fill color of the default labels generated when ``labels``     is set to ``True``. Has no effect for other values of ``labels``. layout     Either one of ``""spring""`` (the default), ``""circular""``, ``""kamada_kawai""``,     ``""planar""``, ``""random""``, ``""shell""``, ``""spectral""``, ``""spiral""``, ``""tree""``, and ``""partite""``     for automatic vertex positioning using ``networkx``     (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_     for more details), or a dictionary specifying a coordinate (value)     for each vertex (key) for manual positioning. layout_config     Only for automatically generated layouts. A dictionary whose entries     are passed as keyword arguments to the automatic layout algorithm     specified via ``layout`` of ``networkx``.     The ``tree`` layout also accepts a special parameter ``vertex_spacing``     passed as a keyword argument inside the ``layout_config`` dictionary.     Passing a tuple ``(space_x, space_y)`` as this argument overrides     the value of ``layout_scale`` and ensures that vertices are arranged     in a way such that the centers of siblings in the same layer are     at least ``space_x`` units apart horizontally, and neighboring layers     are spaced ``space_y`` units vertically. layout_scale     The scale of automatically generated layouts: the vertices will     be arranged such that the coordinates are located within the     interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``     causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,     and the second in ``[-scale_y, scale_y]``. Default: 2. vertex_type     The mobject class used for displaying vertices in the scene. vertex_config     Either a dictionary containing keyword arguments to be passed to     the class specified via ``vertex_type``, or a dictionary whose keys     are the vertices, and whose values are dictionaries containing keyword     arguments for the mobject related to the corresponding vertex. vertex_mobjects     A dictionary whose keys are the vertices, and whose values are     mobjects to be used as vertices. Passing vertices here overrides     all other configuration options for a vertex. edge_type     The mobject class used for displaying edges in the scene. edge_config     Either a dictionary containing keyword arguments to be passed     to the class specified via ``edge_type``, or a dictionary whose     keys are the edges, and whose values are dictionaries containing     keyword arguments for the mobject related to the corresponding edge.     You can further customize the tip by adding a ``tip_config`` dictionary     for global styling, or by adding the dict to a specific ``edge_config``.  Examples --------  .. manim:: MovingDiGraph      class MovingDiGraph(Scene):         def construct(self):             vertices = [1, 2, 3, 4]             edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]              g = DiGraph(vertices, edges)              self.add(g)             self.play(                 g[1].animate.move_to([1, 1, 1]),                 g[2].animate.move_to([-1, 1, 2]),                 g[3].animate.move_to([1, -1, -1]),                 g[4].animate.move_to([-1, -1, 0]),             )             self.wait()  You can customize the edges and arrow tips globally or locally.  .. manim:: CustomDiGraph      class CustomDiGraph(Scene):         def construct(self):             vertices = [i for i in range(5)]             edges = [                 (0, 1),                 (1, 2),                 (3, 2),                 (3, 4),             ]              edge_config = {                 ""stroke_width"": 2,                 ""tip_config"": {                     ""tip_shape"": ArrowSquareTip,                     ""tip_length"": 0.15,                 },                 (3, 4): {                     ""color"": RED,                     ""tip_config"": {""tip_length"": 0.25, ""tip_width"": 0.25}                 },             }              g = DiGraph(                 vertices,                 edges,                 labels=True,                 layout=""circular"",                 edge_config=edge_config,             ).scale(1.4)              self.play(Create(g))             self.wait()  Since this implementation respects the labels boundary you can also use it for an undirected moving graph with labels.  .. manim:: UndirectedMovingDiGraph      class UndirectedMovingDiGraph(Scene):         def construct(self):             vertices = [i for i in range(5)]             edges = [                 (0, 1),                 (1, 2),                 (3, 2),                 (3, 4),             ]              edge_config = {                 ""stroke_width"": 2,                 ""tip_config"": {""tip_length"": 0, ""tip_width"": 0},                 (3, 4): {""color"": RED},             }              g = DiGraph(                 vertices,                 edges,                 labels=True,                 layout=""circular"",                 edge_config=edge_config,             ).scale(1.4)              self.play(Create(g))             self.wait()              self.play(                 g[1].animate.move_to([1, 1, 1]),                 g[2].animate.move_to([-1, 1, 2]),                 g[3].animate.move_to([-1.5, -1.5, -1]),                 g[4].animate.move_to([1, -2, -1]),             )             self.wait()"
GenericGraph,manim.mobject.graph,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graph.py,"Abstract base class for graphs (that is, a collection of vertices connected with edges).  Graphs can be instantiated by passing both a list of (distinct, hashable) vertex names, together with list of edges (as tuples of vertex names). See the examples for concrete implementations of this class for details.  .. note::      This implementation uses updaters to make the edges move with     the vertices.   See also --------  :class:`.Graph` :class:`.DiGraph`   Parameters ----------  vertices     A list of vertices. Must be hashable elements. edges     A list of edges, specified as tuples ``(u, v)`` where both ``u``     and ``v`` are vertices. labels     Controls whether or not vertices are labeled. If ``False`` (the default),     the vertices are not labeled; if ``True`` they are labeled using their     names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,     custom labels can be specified by passing a dictionary whose keys are     the vertices, and whose values are the corresponding vertex labels     (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`). label_fill_color     Sets the fill color of the default labels generated when ``labels``     is set to ``True``. Has no effect for other values of ``labels``. layout     Either one of ``""spring""`` (the default), ``""circular""``, ``""kamada_kawai""``,     ``""planar""``, ``""random""``, ``""shell""``, ``""spectral""``, ``""spiral""``, ``""tree""``, and ``""partite""``     for automatic vertex positioning primarily using ``networkx``     (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_     for more details), a dictionary specifying a coordinate (value)     for each vertex (key) for manual positioning, or a .:class:`~.LayoutFunction` with a user-defined automatic layout. layout_config     Only for automatic layouts. A dictionary whose entries     are passed as keyword arguments to the named layout or automatic layout function     specified via ``layout``.     The ``tree`` layout also accepts a special parameter ``vertex_spacing``     passed as a keyword argument inside the ``layout_config`` dictionary.     Passing a tuple ``(space_x, space_y)`` as this argument overrides     the value of ``layout_scale`` and ensures that vertices are arranged     in a way such that the centers of siblings in the same layer are     at least ``space_x`` units apart horizontally, and neighboring layers     are spaced ``space_y`` units vertically. layout_scale     The scale of automatically generated layouts: the vertices will     be arranged such that the coordinates are located within the     interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``     causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,     and the second in ``[-scale_y, scale_y]``. Default: 2. vertex_type     The mobject class used for displaying vertices in the scene. vertex_config     Either a dictionary containing keyword arguments to be passed to     the class specified via ``vertex_type``, or a dictionary whose keys     are the vertices, and whose values are dictionaries containing keyword     arguments for the mobject related to the corresponding vertex. vertex_mobjects     A dictionary whose keys are the vertices, and whose values are     mobjects to be used as vertices. Passing vertices here overrides     all other configuration options for a vertex. edge_type     The mobject class used for displaying edges in the scene.     Must be a subclass of :class:`~.Line` for default updaters to work. edge_config     Either a dictionary containing keyword arguments to be passed     to the class specified via ``edge_type``, or a dictionary whose     keys are the edges, and whose values are dictionaries containing     keyword arguments for the mobject related to the corresponding edge."
Graph,manim.mobject.graph,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graph.py,"An undirected graph (vertices connected with edges).  The graph comes with an updater which makes the edges stick to the vertices when moved around. See :class:`.DiGraph` for a version with directed edges.  See also --------  :class:`.GenericGraph`  Parameters ----------  vertices     A list of vertices. Must be hashable elements. edges     A list of edges, specified as tuples ``(u, v)`` where both ``u``     and ``v`` are vertices. The vertex order is irrelevant. labels     Controls whether or not vertices are labeled. If ``False`` (the default),     the vertices are not labeled; if ``True`` they are labeled using their     names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,     custom labels can be specified by passing a dictionary whose keys are     the vertices, and whose values are the corresponding vertex labels     (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`). label_fill_color     Sets the fill color of the default labels generated when ``labels``     is set to ``True``. Has no effect for other values of ``labels``. layout     Either one of ``""spring""`` (the default), ``""circular""``, ``""kamada_kawai""``,     ``""planar""``, ``""random""``, ``""shell""``, ``""spectral""``, ``""spiral""``, ``""tree""``, and ``""partite""``     for automatic vertex positioning using ``networkx``     (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_     for more details), or a dictionary specifying a coordinate (value)     for each vertex (key) for manual positioning. layout_config     Only for automatically generated layouts. A dictionary whose entries     are passed as keyword arguments to the automatic layout algorithm     specified via ``layout`` of ``networkx``.     The ``tree`` layout also accepts a special parameter ``vertex_spacing``     passed as a keyword argument inside the ``layout_config`` dictionary.     Passing a tuple ``(space_x, space_y)`` as this argument overrides     the value of ``layout_scale`` and ensures that vertices are arranged     in a way such that the centers of siblings in the same layer are     at least ``space_x`` units apart horizontally, and neighboring layers     are spaced ``space_y`` units vertically. layout_scale     The scale of automatically generated layouts: the vertices will     be arranged such that the coordinates are located within the     interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``     causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,     and the second in ``[-scale_y, scale_y]``. Default: 2. vertex_type     The mobject class used for displaying vertices in the scene. vertex_config     Either a dictionary containing keyword arguments to be passed to     the class specified via ``vertex_type``, or a dictionary whose keys     are the vertices, and whose values are dictionaries containing keyword     arguments for the mobject related to the corresponding vertex. vertex_mobjects     A dictionary whose keys are the vertices, and whose values are     mobjects to be used as vertices. Passing vertices here overrides     all other configuration options for a vertex. edge_type     The mobject class used for displaying edges in the scene. edge_config     Either a dictionary containing keyword arguments to be passed     to the class specified via ``edge_type``, or a dictionary whose     keys are the edges, and whose values are dictionaries containing     keyword arguments for the mobject related to the corresponding edge.   Examples --------  First, we create a small graph and demonstrate that the edges move together with the vertices.  .. manim:: MovingVertices      class MovingVertices(Scene):         def construct(self):             vertices = [1, 2, 3, 4]             edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]             g = Graph(vertices, edges)             self.play(Create(g))             self.wait()             self.play(g[1].animate.move_to([1, 1, 0]),                       g[2].animate.move_to([-1, 1, 0]),                       g[3].animate.move_to([1, -1, 0]),                       g[4].animate.move_to([-1, -1, 0]))             self.wait()  There are several automatic positioning algorithms to choose from:  .. manim:: GraphAutoPosition     :save_last_frame:      class GraphAutoPosition(Scene):         def construct(self):             vertices = [1, 2, 3, 4, 5, 6, 7, 8]             edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),                      (2, 8), (3, 4), (6, 1), (6, 2),                      (6, 3), (7, 2), (7, 4)]             autolayouts = [""spring"", ""circular"", ""kamada_kawai"",                            ""planar"", ""random"", ""shell"",                            ""spectral"", ""spiral""]             graphs = [Graph(vertices, edges, layout=lt).scale(0.5)                       for lt in autolayouts]             r1 = VGroup(*graphs[:3]).arrange()             r2 = VGroup(*graphs[3:6]).arrange()             r3 = VGroup(*graphs[6:]).arrange()             self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))  Vertices can also be positioned manually:  .. manim:: GraphManualPosition     :save_last_frame:      class GraphManualPosition(Scene):         def construct(self):             vertices = [1, 2, 3, 4]             edges = [(1, 2), (2, 3), (3, 4), (4, 1)]             lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}             G = Graph(vertices, edges, layout=lt)             self.add(G)  The vertices in graphs can be labeled, and configurations for vertices and edges can be modified both by default and for specific vertices and edges.  .. note::      In ``edge_config``, edges can be passed in both directions: if     ``(u, v)`` is an edge in the graph, both ``(u, v)`` as well     as ``(v, u)`` can be used as keys in the dictionary.  .. manim:: LabeledModifiedGraph     :save_last_frame:      class LabeledModifiedGraph(Scene):         def construct(self):             vertices = [1, 2, 3, 4, 5, 6, 7, 8]             edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),                      (2, 8), (3, 4), (6, 1), (6, 2),                      (6, 3), (7, 2), (7, 4)]             g = Graph(vertices, edges, layout=""circular"", layout_scale=3,                       labels=True, vertex_config={7: {""fill_color"": RED}},                       edge_config={(1, 7): {""stroke_color"": RED},                                    (2, 7): {""stroke_color"": RED},                                    (4, 7): {""stroke_color"": RED}})             self.add(g)  You can also lay out a partite graph on columns by specifying a list of the vertices on each side and choosing the partite layout.  .. note::      All vertices in your graph which are not listed in any of the partitions     are collected in their own partition and rendered in the rightmost column.  .. manim:: PartiteGraph     :save_last_frame:      import networkx as nx      class PartiteGraph(Scene):         def construct(self):             G = nx.Graph()             G.add_nodes_from([0, 1, 2, 3])             G.add_edges_from([(0, 2), (0,3), (1, 2)])             graph = Graph(list(G.nodes), list(G.edges), layout=""partite"", partitions=[[0, 1]])             self.play(Create(graph))  The representation of a linear artificial neural network is facilitated by the use of the partite layout and defining partitions for each layer.  .. manim:: LinearNN     :save_last_frame:      class LinearNN(Scene):         def construct(self):             edges = []             partitions = []             c = 0             layers = [2, 3, 3, 2]  # the number of neurons in each layer              for i in layers:                 partitions.append(list(range(c + 1, c + i + 1)))                 c += i             for i, v in enumerate(layers[1:]):                     last = sum(layers[:i+1])                     for j in range(v):                         for k in range(last - layers[i], last):                             edges.append((k + 1, j + last + 1))              vertices = np.arange(1, sum(layers) + 1)              graph = Graph(                 vertices,                 edges,                 layout='partite',                 partitions=partitions,                 layout_scale=3,                 vertex_config={'radius': 0.20},             )             self.add(graph)  The custom tree layout can be used to show the graph by distance from the root vertex. You must pass the root vertex of the tree.  .. manim:: Tree      import networkx as nx      class Tree(Scene):         def construct(self):             G = nx.Graph()              G.add_node(""ROOT"")              for i in range(5):                 G.add_node(""Child_%i"" % i)                 G.add_node(""Grandchild_%i"" % i)                 G.add_node(""Greatgrandchild_%i"" % i)                  G.add_edge(""ROOT"", ""Child_%i"" % i)                 G.add_edge(""Child_%i"" % i, ""Grandchild_%i"" % i)                 G.add_edge(""Grandchild_%i"" % i, ""Greatgrandchild_%i"" % i)              self.play(Create(                 Graph(list(G.nodes), list(G.edges), layout=""tree"", root_vertex=""ROOT"")))  The following code sample illustrates the use of the ``vertex_spacing`` layout parameter specific to the ``""tree""`` layout. As mentioned above, setting ``vertex_spacing`` overrides the specified value for ``layout_scale``, and as such it is harder to control the size of the mobject. However, we can adjust the captured frame and zoom out by using a :class:`.MovingCameraScene`::      class LargeTreeGeneration(MovingCameraScene):         DEPTH = 4         CHILDREN_PER_VERTEX = 3         LAYOUT_CONFIG = {""vertex_spacing"": (0.5, 1)}         VERTEX_CONF = {""radius"": 0.25, ""color"": BLUE_B, ""fill_opacity"": 1}          def expand_vertex(self, g, vertex_id: str, depth: int):             new_vertices = [                 f""{vertex_id}/{i}"" for i in range(self.CHILDREN_PER_VERTEX)             ]             new_edges = [(vertex_id, child_id) for child_id in new_vertices]             g.add_edges(                 *new_edges,                 vertex_config=self.VERTEX_CONF,                 positions={                     k: g.vertices[vertex_id].get_center() + 0.1 * DOWN                     for k in new_vertices                 },             )             if depth < self.DEPTH:                 for child_id in new_vertices:                     self.expand_vertex(g, child_id, depth + 1)              return g          def construct(self):             g = Graph([""ROOT""], [], vertex_config=self.VERTEX_CONF)             g = self.expand_vertex(g, ""ROOT"", 1)             self.add(g)              self.play(                 g.animate.change_layout(                     ""tree"",                     root_vertex=""ROOT"",                     layout_config=self.LAYOUT_CONFIG,                 )             )             self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)"
Graph,manim.mobject.graph,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graph.py,"An undirected graph (vertices connected with edges).  The graph comes with an updater which makes the edges stick to the vertices when moved around. See :class:`.DiGraph` for a version with directed edges.  See also --------  :class:`.GenericGraph`  Parameters ----------  vertices     A list of vertices. Must be hashable elements. edges     A list of edges, specified as tuples ``(u, v)`` where both ``u``     and ``v`` are vertices. The vertex order is irrelevant. labels     Controls whether or not vertices are labeled. If ``False`` (the default),     the vertices are not labeled; if ``True`` they are labeled using their     names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,     custom labels can be specified by passing a dictionary whose keys are     the vertices, and whose values are the corresponding vertex labels     (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`). label_fill_color     Sets the fill color of the default labels generated when ``labels``     is set to ``True``. Has no effect for other values of ``labels``. layout     Either one of ``""spring""`` (the default), ``""circular""``, ``""kamada_kawai""``,     ``""planar""``, ``""random""``, ``""shell""``, ``""spectral""``, ``""spiral""``, ``""tree""``, and ``""partite""``     for automatic vertex positioning using ``networkx``     (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_     for more details), or a dictionary specifying a coordinate (value)     for each vertex (key) for manual positioning. layout_config     Only for automatically generated layouts. A dictionary whose entries     are passed as keyword arguments to the automatic layout algorithm     specified via ``layout`` of ``networkx``.     The ``tree`` layout also accepts a special parameter ``vertex_spacing``     passed as a keyword argument inside the ``layout_config`` dictionary.     Passing a tuple ``(space_x, space_y)`` as this argument overrides     the value of ``layout_scale`` and ensures that vertices are arranged     in a way such that the centers of siblings in the same layer are     at least ``space_x`` units apart horizontally, and neighboring layers     are spaced ``space_y`` units vertically. layout_scale     The scale of automatically generated layouts: the vertices will     be arranged such that the coordinates are located within the     interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``     causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,     and the second in ``[-scale_y, scale_y]``. Default: 2. vertex_type     The mobject class used for displaying vertices in the scene. vertex_config     Either a dictionary containing keyword arguments to be passed to     the class specified via ``vertex_type``, or a dictionary whose keys     are the vertices, and whose values are dictionaries containing keyword     arguments for the mobject related to the corresponding vertex. vertex_mobjects     A dictionary whose keys are the vertices, and whose values are     mobjects to be used as vertices. Passing vertices here overrides     all other configuration options for a vertex. edge_type     The mobject class used for displaying edges in the scene. edge_config     Either a dictionary containing keyword arguments to be passed     to the class specified via ``edge_type``, or a dictionary whose     keys are the edges, and whose values are dictionaries containing     keyword arguments for the mobject related to the corresponding edge.   Examples --------  First, we create a small graph and demonstrate that the edges move together with the vertices.  .. manim:: MovingVertices      class MovingVertices(Scene):         def construct(self):             vertices = [1, 2, 3, 4]             edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]             g = Graph(vertices, edges)             self.play(Create(g))             self.wait()             self.play(g[1].animate.move_to([1, 1, 0]),                       g[2].animate.move_to([-1, 1, 0]),                       g[3].animate.move_to([1, -1, 0]),                       g[4].animate.move_to([-1, -1, 0]))             self.wait()  There are several automatic positioning algorithms to choose from:  .. manim:: GraphAutoPosition     :save_last_frame:      class GraphAutoPosition(Scene):         def construct(self):             vertices = [1, 2, 3, 4, 5, 6, 7, 8]             edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),                      (2, 8), (3, 4), (6, 1), (6, 2),                      (6, 3), (7, 2), (7, 4)]             autolayouts = [""spring"", ""circular"", ""kamada_kawai"",                            ""planar"", ""random"", ""shell"",                            ""spectral"", ""spiral""]             graphs = [Graph(vertices, edges, layout=lt).scale(0.5)                       for lt in autolayouts]             r1 = VGroup(*graphs[:3]).arrange()             r2 = VGroup(*graphs[3:6]).arrange()             r3 = VGroup(*graphs[6:]).arrange()             self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))  Vertices can also be positioned manually:  .. manim:: GraphManualPosition     :save_last_frame:      class GraphManualPosition(Scene):         def construct(self):             vertices = [1, 2, 3, 4]             edges = [(1, 2), (2, 3), (3, 4), (4, 1)]             lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}             G = Graph(vertices, edges, layout=lt)             self.add(G)  The vertices in graphs can be labeled, and configurations for vertices and edges can be modified both by default and for specific vertices and edges.  .. note::      In ``edge_config``, edges can be passed in both directions: if     ``(u, v)`` is an edge in the graph, both ``(u, v)`` as well     as ``(v, u)`` can be used as keys in the dictionary.  .. manim:: LabeledModifiedGraph     :save_last_frame:      class LabeledModifiedGraph(Scene):         def construct(self):             vertices = [1, 2, 3, 4, 5, 6, 7, 8]             edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),                      (2, 8), (3, 4), (6, 1), (6, 2),                      (6, 3), (7, 2), (7, 4)]             g = Graph(vertices, edges, layout=""circular"", layout_scale=3,                       labels=True, vertex_config={7: {""fill_color"": RED}},                       edge_config={(1, 7): {""stroke_color"": RED},                                    (2, 7): {""stroke_color"": RED},                                    (4, 7): {""stroke_color"": RED}})             self.add(g)  You can also lay out a partite graph on columns by specifying a list of the vertices on each side and choosing the partite layout.  .. note::      All vertices in your graph which are not listed in any of the partitions     are collected in their own partition and rendered in the rightmost column.  .. manim:: PartiteGraph     :save_last_frame:      import networkx as nx      class PartiteGraph(Scene):         def construct(self):             G = nx.Graph()             G.add_nodes_from([0, 1, 2, 3])             G.add_edges_from([(0, 2), (0,3), (1, 2)])             graph = Graph(list(G.nodes), list(G.edges), layout=""partite"", partitions=[[0, 1]])             self.play(Create(graph))  The representation of a linear artificial neural network is facilitated by the use of the partite layout and defining partitions for each layer.  .. manim:: LinearNN     :save_last_frame:      class LinearNN(Scene):         def construct(self):             edges = []             partitions = []             c = 0             layers = [2, 3, 3, 2]  # the number of neurons in each layer              for i in layers:                 partitions.append(list(range(c + 1, c + i + 1)))                 c += i             for i, v in enumerate(layers[1:]):                     last = sum(layers[:i+1])                     for j in range(v):                         for k in range(last - layers[i], last):                             edges.append((k + 1, j + last + 1))              vertices = np.arange(1, sum(layers) + 1)              graph = Graph(                 vertices,                 edges,                 layout='partite',                 partitions=partitions,                 layout_scale=3,                 vertex_config={'radius': 0.20},             )             self.add(graph)  The custom tree layout can be used to show the graph by distance from the root vertex. You must pass the root vertex of the tree.  .. manim:: Tree      import networkx as nx      class Tree(Scene):         def construct(self):             G = nx.Graph()              G.add_node(""ROOT"")              for i in range(5):                 G.add_node(""Child_%i"" % i)                 G.add_node(""Grandchild_%i"" % i)                 G.add_node(""Greatgrandchild_%i"" % i)                  G.add_edge(""ROOT"", ""Child_%i"" % i)                 G.add_edge(""Child_%i"" % i, ""Grandchild_%i"" % i)                 G.add_edge(""Grandchild_%i"" % i, ""Greatgrandchild_%i"" % i)              self.play(Create(                 Graph(list(G.nodes), list(G.edges), layout=""tree"", root_vertex=""ROOT"")))  The following code sample illustrates the use of the ``vertex_spacing`` layout parameter specific to the ``""tree""`` layout. As mentioned above, setting ``vertex_spacing`` overrides the specified value for ``layout_scale``, and as such it is harder to control the size of the mobject. However, we can adjust the captured frame and zoom out by using a :class:`.MovingCameraScene`::      class LargeTreeGeneration(MovingCameraScene):         DEPTH = 4         CHILDREN_PER_VERTEX = 3         LAYOUT_CONFIG = {""vertex_spacing"": (0.5, 1)}         VERTEX_CONF = {""radius"": 0.25, ""color"": BLUE_B, ""fill_opacity"": 1}          def expand_vertex(self, g, vertex_id: str, depth: int):             new_vertices = [                 f""{vertex_id}/{i}"" for i in range(self.CHILDREN_PER_VERTEX)             ]             new_edges = [(vertex_id, child_id) for child_id in new_vertices]             g.add_edges(                 *new_edges,                 vertex_config=self.VERTEX_CONF,                 positions={                     k: g.vertices[vertex_id].get_center() + 0.1 * DOWN                     for k in new_vertices                 },             )             if depth < self.DEPTH:                 for child_id in new_vertices:                     self.expand_vertex(g, child_id, depth + 1)              return g          def construct(self):             g = Graph([""ROOT""], [], vertex_config=self.VERTEX_CONF)             g = self.expand_vertex(g, ""ROOT"", 1)             self.add(g)              self.play(                 g.animate.change_layout(                     ""tree"",                     root_vertex=""ROOT"",                     layout_config=self.LAYOUT_CONFIG,                 )             )             self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)"
Axes,manim.mobject.graphing.coordinate_systems,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/coordinate_systems.py,"Creates a set of axes.  Parameters ---------- x_range     The ``(x_min, x_max, x_step)`` values of the x-axis. y_range     The ``(y_min, y_max, y_step)`` values of the y-axis. x_length     The length of the x-axis. y_length     The length of the y-axis. axis_config     Arguments to be passed to :class:`~.NumberLine` that influences both axes. x_axis_config     Arguments to be passed to :class:`~.NumberLine` that influence the x-axis. y_axis_config     Arguments to be passed to :class:`~.NumberLine` that influence the y-axis. tips     Whether or not to include the tips on both axes. kwargs     Additional arguments to be passed to :class:`CoordinateSystem` and :class:`~.VGroup`.  Examples -------- .. manim:: LogScalingExample     :save_last_frame:      class LogScalingExample(Scene):         def construct(self):             ax = Axes(                 x_range=[0, 10, 1],                 y_range=[-2, 6, 1],                 tips=False,                 axis_config={""include_numbers"": True},                 y_axis_config={""scaling"": LogBase(custom_labels=True)},             )              # x_min must be > 0 because log is undefined at 0.             graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)             self.add(ax, graph)  Styling arguments can be passed to the underlying :class:`.NumberLine` mobjects that represent the axes:  .. manim:: AxesWithDifferentTips     :save_last_frame:      class AxesWithDifferentTips(Scene):         def construct(self):             ax = Axes(axis_config={'tip_shape': StealthTip})             self.add(ax)"
Axes,manim.mobject.graphing.coordinate_systems,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/coordinate_systems.py,"Creates a set of axes.  Parameters ---------- x_range     The ``(x_min, x_max, x_step)`` values of the x-axis. y_range     The ``(y_min, y_max, y_step)`` values of the y-axis. x_length     The length of the x-axis. y_length     The length of the y-axis. axis_config     Arguments to be passed to :class:`~.NumberLine` that influences both axes. x_axis_config     Arguments to be passed to :class:`~.NumberLine` that influence the x-axis. y_axis_config     Arguments to be passed to :class:`~.NumberLine` that influence the y-axis. tips     Whether or not to include the tips on both axes. kwargs     Additional arguments to be passed to :class:`CoordinateSystem` and :class:`~.VGroup`.  Examples -------- .. manim:: LogScalingExample     :save_last_frame:      class LogScalingExample(Scene):         def construct(self):             ax = Axes(                 x_range=[0, 10, 1],                 y_range=[-2, 6, 1],                 tips=False,                 axis_config={""include_numbers"": True},                 y_axis_config={""scaling"": LogBase(custom_labels=True)},             )              # x_min must be > 0 because log is undefined at 0.             graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)             self.add(ax, graph)  Styling arguments can be passed to the underlying :class:`.NumberLine` mobjects that represent the axes:  .. manim:: AxesWithDifferentTips     :save_last_frame:      class AxesWithDifferentTips(Scene):         def construct(self):             ax = Axes(axis_config={'tip_shape': StealthTip})             self.add(ax)"
ComplexPlane,manim.mobject.graphing.coordinate_systems,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/coordinate_systems.py,"A :class:`~.NumberPlane` specialized for use with complex numbers.  Examples -------- .. manim:: ComplexPlaneExample     :save_last_frame:     :ref_classes: Dot MathTex      class ComplexPlaneExample(Scene):         def construct(self):             plane = ComplexPlane().add_coordinates()             self.add(plane)             d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)             d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)             label1 = MathTex(""2+i"").next_to(d1, UR, 0.1)             label2 = MathTex(""-3-2i"").next_to(d2, UR, 0.1)             self.add(                 d1,                 label1,                 d2,                 label2,             )"
NumberPlane,manim.mobject.graphing.coordinate_systems,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/coordinate_systems.py,"Creates a cartesian plane with background lines.  Parameters ---------- x_range     The ``[x_min, x_max, x_step]`` values of the plane in the horizontal direction. y_range     The ``[y_min, y_max, y_step]`` values of the plane in the vertical direction. x_length     The width of the plane. y_length     The height of the plane. background_line_style     Arguments that influence the construction of the background lines of the plane. faded_line_style     Similar to :attr:`background_line_style`, affects the construction of the scene's background lines. faded_line_ratio     Determines the number of boxes within the background lines: :code:`2` = 4 boxes, :code:`3` = 9 boxes. make_smooth_after_applying_functions     Currently non-functional. kwargs     Additional arguments to be passed to :class:`Axes`.   .. note::     If :attr:`x_length` or :attr:`y_length` are not defined, they are automatically calculated such that     one unit on each axis is one Manim unit long.  Examples -------- .. manim:: NumberPlaneExample     :save_last_frame:      class NumberPlaneExample(Scene):         def construct(self):             number_plane = NumberPlane(                 background_line_style={                     ""stroke_color"": TEAL,                     ""stroke_width"": 4,                     ""stroke_opacity"": 0.6                 }             )             self.add(number_plane)  .. manim:: NumberPlaneScaled     :save_last_frame:      class NumberPlaneScaled(Scene):         def construct(self):             number_plane = NumberPlane(                 x_range=(-4, 11, 1),                 y_range=(-3, 3, 1),                 x_length=5,                 y_length=2,             ).move_to(LEFT*3)              number_plane_scaled_y = NumberPlane(                 x_range=(-4, 11, 1),                 x_length=5,                 y_length=4,             ).move_to(RIGHT*3)              self.add(number_plane)             self.add(number_plane_scaled_y)"
PolarPlane,manim.mobject.graphing.coordinate_systems,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/coordinate_systems.py,"Creates a polar plane with background lines.  Parameters ---------- azimuth_step     The number of divisions in the azimuth (also known as the `angular coordinate` or `polar angle`). If ``None`` is specified then it will use the default     specified by ``azimuth_units``:      - ``""PI radians""`` or ``""TAU radians""``: 20     - ``""degrees""``: 36     - ``""gradians""``: 40     - ``None``: 1      A non-integer value will result in a partial division at the end of the circle.  size     The diameter of the plane.  radius_step     The distance between faded radius lines.  radius_max     The maximum value of the radius.  azimuth_units     Specifies a default labelling system for the azimuth. Choices are:      - ``""PI radians""``: Fractional labels in the interval :math:`\left[0, 2\pi\right]` with :math:`\pi` as a constant.     - ``""TAU radians""``: Fractional labels in the interval :math:`\left[0, \tau\right]` (where :math:`\tau = 2\pi`) with :math:`\tau` as a constant.     - ``""degrees""``: Decimal labels in the interval :math:`\left[0, 360\right]` with a degree (:math:`^{\circ}`) symbol.     - ``""gradians""``: Decimal labels in the interval :math:`\left[0, 400\right]` with a superscript ""g"" (:math:`^{g}`).     - ``None``: Decimal labels in the interval :math:`\left[0, 1\right]`.  azimuth_compact_fraction     If the ``azimuth_units`` choice has fractional labels, choose whether to     combine the constant in a compact form :math:`\tfrac{xu}{y}` as opposed to     :math:`\tfrac{x}{y}u`, where :math:`u` is the constant.  azimuth_offset     The angle offset of the azimuth, expressed in radians.  azimuth_direction     The direction of the azimuth.      - ``""CW""``: Clockwise.     - ``""CCW""``: Anti-clockwise.  azimuth_label_buff     The buffer for the azimuth labels.  azimuth_label_font_size     The font size of the azimuth labels.  radius_config     The axis config for the radius.  Examples -------- .. manim:: PolarPlaneExample     :ref_classes: PolarPlane     :save_last_frame:      class PolarPlaneExample(Scene):         def construct(self):             polarplane_pi = PolarPlane(                 azimuth_units=""PI radians"",                 size=6,                 azimuth_label_font_size=33.6,                 radius_config={""font_size"": 33.6},             ).add_coordinates()             self.add(polarplane_pi)"
ThreeDAxes,manim.mobject.graphing.coordinate_systems,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/coordinate_systems.py,"A 3-dimensional set of axes.  Parameters ---------- x_range     The ``[x_min, x_max, x_step]`` values of the x-axis. y_range     The ``[y_min, y_max, y_step]`` values of the y-axis. z_range     The ``[z_min, z_max, z_step]`` values of the z-axis. x_length     The length of the x-axis. y_length     The length of the y-axis. z_length     The length of the z-axis. z_axis_config     Arguments to be passed to :class:`~.NumberLine` that influence the z-axis. z_normal     The direction of the normal. num_axis_pieces     The number of pieces used to construct the axes. light_source     The direction of the light source. depth     Currently non-functional. gloss     Currently non-functional. kwargs     Additional arguments to be passed to :class:`Axes`."
FunctionGraph,manim.mobject.graphing.functions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/functions.py,"A :class:`ParametricFunction` that spans the length of the scene by default.  Examples -------- .. manim:: ExampleFunctionGraph     :save_last_frame:      class ExampleFunctionGraph(Scene):         def construct(self):             cos_func = FunctionGraph(                 lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),                 color=RED,             )              sin_func_1 = FunctionGraph(                 lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),                 color=BLUE,             )              sin_func_2 = FunctionGraph(                 lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),                 x_range=[-4, 4],                 color=GREEN,             ).move_to([0, 1, 0])              self.add(cos_func, sin_func_1, sin_func_2)"
ImplicitFunction,manim.mobject.graphing.functions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/functions.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
ImplicitFunction,manim.mobject.graphing.functions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/functions.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
ParametricFunction,manim.mobject.graphing.functions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/functions.py,"A parametric curve.  Parameters ---------- function     The function to be plotted in the form of ``(lambda t: (x(t), y(t), z(t)))`` t_range     Determines the length that the function spans in the form of (t_min, t_max, step=0.01). By default ``[0, 1]`` scaling     Scaling class applied to the points of the function. Default of :class:`~.LinearBase`. use_smoothing     Whether to interpolate between the points of the function after they have been created.     (Will have odd behaviour with a low number of points) use_vectorized     Whether to pass in the generated t value array to the function as ``[t_0, t_1, ...]``.     Only use this if your function supports it. Output should be a numpy array     of shape ``[[x_0, x_1, ...], [y_0, y_1, ...], [z_0, z_1, ...]]`` but ``z`` can     also be 0 if the Axes is 2D discontinuities     Values of t at which the function experiences discontinuity. dt     The left and right tolerance for the discontinuities.   Examples -------- .. manim:: PlotParametricFunction     :save_last_frame:      class PlotParametricFunction(Scene):         def func(self, t):             return (np.sin(2 * t), np.sin(3 * t), 0)          def construct(self):             func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)             self.add(func.scale(3))  .. manim:: ThreeDParametricSpring     :save_last_frame:      class ThreeDParametricSpring(ThreeDScene):         def construct(self):             curve1 = ParametricFunction(                 lambda u: (                     1.2 * np.cos(u),                     1.2 * np.sin(u),                     u * 0.05                 ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)             ).set_shade_in_3d(True)             axes = ThreeDAxes()             self.add(axes, curve1)             self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)             self.wait()  .. attention::     If your function has discontinuities, you'll have to specify the location     of the discontinuities manually. See the following example for guidance.  .. manim:: DiscontinuousExample     :save_last_frame:      class DiscontinuousExample(Scene):         def construct(self):             ax1 = NumberPlane((-3, 3), (-4, 4))             ax2 = NumberPlane((-3, 3), (-4, 4))             VGroup(ax1, ax2).arrange()             discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)             incorrect = ax1.plot(discontinuous_function, color=RED)             correct = ax2.plot(                 discontinuous_function,                 discontinuities=[-2, 2],  # discontinuous points                 dt=0.1,  # left and right tolerance of discontinuity                 color=GREEN,             )             self.add(ax1, ax2, incorrect, correct)"
ParametricFunction,manim.mobject.graphing.functions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/functions.py,"A parametric curve.  Parameters ---------- function     The function to be plotted in the form of ``(lambda t: (x(t), y(t), z(t)))`` t_range     Determines the length that the function spans in the form of (t_min, t_max, step=0.01). By default ``[0, 1]`` scaling     Scaling class applied to the points of the function. Default of :class:`~.LinearBase`. use_smoothing     Whether to interpolate between the points of the function after they have been created.     (Will have odd behaviour with a low number of points) use_vectorized     Whether to pass in the generated t value array to the function as ``[t_0, t_1, ...]``.     Only use this if your function supports it. Output should be a numpy array     of shape ``[[x_0, x_1, ...], [y_0, y_1, ...], [z_0, z_1, ...]]`` but ``z`` can     also be 0 if the Axes is 2D discontinuities     Values of t at which the function experiences discontinuity. dt     The left and right tolerance for the discontinuities.   Examples -------- .. manim:: PlotParametricFunction     :save_last_frame:      class PlotParametricFunction(Scene):         def func(self, t):             return (np.sin(2 * t), np.sin(3 * t), 0)          def construct(self):             func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)             self.add(func.scale(3))  .. manim:: ThreeDParametricSpring     :save_last_frame:      class ThreeDParametricSpring(ThreeDScene):         def construct(self):             curve1 = ParametricFunction(                 lambda u: (                     1.2 * np.cos(u),                     1.2 * np.sin(u),                     u * 0.05                 ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)             ).set_shade_in_3d(True)             axes = ThreeDAxes()             self.add(axes, curve1)             self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)             self.wait()  .. attention::     If your function has discontinuities, you'll have to specify the location     of the discontinuities manually. See the following example for guidance.  .. manim:: DiscontinuousExample     :save_last_frame:      class DiscontinuousExample(Scene):         def construct(self):             ax1 = NumberPlane((-3, 3), (-4, 4))             ax2 = NumberPlane((-3, 3), (-4, 4))             VGroup(ax1, ax2).arrange()             discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)             incorrect = ax1.plot(discontinuous_function, color=RED)             correct = ax2.plot(                 discontinuous_function,                 discontinuities=[-2, 2],  # discontinuous points                 dt=0.1,  # left and right tolerance of discontinuity                 color=GREEN,             )             self.add(ax1, ax2, incorrect, correct)"
NumberLine,manim.mobject.graphing.number_line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/number_line.py,"Creates a number line with tick marks.  Parameters ---------- x_range     The ``[x_min, x_max, x_step]`` values to create the line. length     The length of the number line. unit_size     The distance between each tick of the line. Overwritten by :attr:`length`, if specified. include_ticks     Whether to include ticks on the number line. tick_size     The length of each tick mark. numbers_with_elongated_ticks     An iterable of specific values with elongated ticks. longer_tick_multiple     Influences how many times larger elongated ticks are than regular ticks (2 = 2x). rotation     The angle (in radians) at which the line is rotated. stroke_width     The thickness of the line. include_tip     Whether to add a tip to the end of the line. tip_width     The width of the tip. tip_height     The height of the tip. tip_shape     The mobject class used to construct the tip, or ``None`` (the     default) for the default arrow tip. Passed classes have to inherit     from :class:`.ArrowTip`. include_numbers     Whether to add numbers to the tick marks. The number of decimal places is determined     by the step size, this default can be overridden by ``decimal_number_config``. scaling     The way the ``x_range`` is value is scaled, i.e. :class:`~.LogBase` for a logarithmic numberline. Defaults to :class:`~.LinearBase`. font_size     The size of the label mobjects. Defaults to 36. label_direction     The specific position to which label mobjects are added on the line. label_constructor     Determines the mobject class that will be used to construct the labels of the number line. line_to_number_buff     The distance between the line and the label mobject. decimal_number_config     Arguments that can be passed to :class:`~.numbers.DecimalNumber` to influence number mobjects. numbers_to_exclude     An explicit iterable of numbers to not be added to the number line. numbers_to_include     An explicit iterable of numbers to add to the number line kwargs     Additional arguments to be passed to :class:`~.Line`.   .. note::      Number ranges that include both negative and positive values will be generated     from the 0 point, and may not include a tick at the min / max     values as the tick locations are dependent on the step size.  Examples -------- .. manim:: NumberLineExample     :save_last_frame:      class NumberLineExample(Scene):         def construct(self):             l0 = NumberLine(                 x_range=[-10, 10, 2],                 length=10,                 color=BLUE,                 include_numbers=True,                 label_direction=UP,             )              l1 = NumberLine(                 x_range=[-10, 10, 2],                 unit_size=0.5,                 numbers_with_elongated_ticks=[-2, 4],                 include_numbers=True,                 font_size=24,             )             num6 = l1.numbers[8]             num6.set_color(RED)              l2 = NumberLine(                 x_range=[-2.5, 2.5 + 0.5, 0.5],                 length=12,                 decimal_number_config={""num_decimal_places"": 2},                 include_numbers=True,             )              l3 = NumberLine(                 x_range=[-5, 5 + 1, 1],                 length=6,                 include_tip=True,                 include_numbers=True,                 rotation=10 * DEGREES,             )              line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)             self.add(line_group)"
NumberLine,manim.mobject.graphing.number_line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/number_line.py,"Creates a number line with tick marks.  Parameters ---------- x_range     The ``[x_min, x_max, x_step]`` values to create the line. length     The length of the number line. unit_size     The distance between each tick of the line. Overwritten by :attr:`length`, if specified. include_ticks     Whether to include ticks on the number line. tick_size     The length of each tick mark. numbers_with_elongated_ticks     An iterable of specific values with elongated ticks. longer_tick_multiple     Influences how many times larger elongated ticks are than regular ticks (2 = 2x). rotation     The angle (in radians) at which the line is rotated. stroke_width     The thickness of the line. include_tip     Whether to add a tip to the end of the line. tip_width     The width of the tip. tip_height     The height of the tip. tip_shape     The mobject class used to construct the tip, or ``None`` (the     default) for the default arrow tip. Passed classes have to inherit     from :class:`.ArrowTip`. include_numbers     Whether to add numbers to the tick marks. The number of decimal places is determined     by the step size, this default can be overridden by ``decimal_number_config``. scaling     The way the ``x_range`` is value is scaled, i.e. :class:`~.LogBase` for a logarithmic numberline. Defaults to :class:`~.LinearBase`. font_size     The size of the label mobjects. Defaults to 36. label_direction     The specific position to which label mobjects are added on the line. label_constructor     Determines the mobject class that will be used to construct the labels of the number line. line_to_number_buff     The distance between the line and the label mobject. decimal_number_config     Arguments that can be passed to :class:`~.numbers.DecimalNumber` to influence number mobjects. numbers_to_exclude     An explicit iterable of numbers to not be added to the number line. numbers_to_include     An explicit iterable of numbers to add to the number line kwargs     Additional arguments to be passed to :class:`~.Line`.   .. note::      Number ranges that include both negative and positive values will be generated     from the 0 point, and may not include a tick at the min / max     values as the tick locations are dependent on the step size.  Examples -------- .. manim:: NumberLineExample     :save_last_frame:      class NumberLineExample(Scene):         def construct(self):             l0 = NumberLine(                 x_range=[-10, 10, 2],                 length=10,                 color=BLUE,                 include_numbers=True,                 label_direction=UP,             )              l1 = NumberLine(                 x_range=[-10, 10, 2],                 unit_size=0.5,                 numbers_with_elongated_ticks=[-2, 4],                 include_numbers=True,                 font_size=24,             )             num6 = l1.numbers[8]             num6.set_color(RED)              l2 = NumberLine(                 x_range=[-2.5, 2.5 + 0.5, 0.5],                 length=12,                 decimal_number_config={""num_decimal_places"": 2},                 include_numbers=True,             )              l3 = NumberLine(                 x_range=[-5, 5 + 1, 1],                 length=6,                 include_tip=True,                 include_numbers=True,                 rotation=10 * DEGREES,             )              line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)             self.add(line_group)"
UnitInterval,manim.mobject.graphing.number_line,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/number_line.py,"Creates a number line with tick marks.  Parameters ---------- x_range     The ``[x_min, x_max, x_step]`` values to create the line. length     The length of the number line. unit_size     The distance between each tick of the line. Overwritten by :attr:`length`, if specified. include_ticks     Whether to include ticks on the number line. tick_size     The length of each tick mark. numbers_with_elongated_ticks     An iterable of specific values with elongated ticks. longer_tick_multiple     Influences how many times larger elongated ticks are than regular ticks (2 = 2x). rotation     The angle (in radians) at which the line is rotated. stroke_width     The thickness of the line. include_tip     Whether to add a tip to the end of the line. tip_width     The width of the tip. tip_height     The height of the tip. tip_shape     The mobject class used to construct the tip, or ``None`` (the     default) for the default arrow tip. Passed classes have to inherit     from :class:`.ArrowTip`. include_numbers     Whether to add numbers to the tick marks. The number of decimal places is determined     by the step size, this default can be overridden by ``decimal_number_config``. scaling     The way the ``x_range`` is value is scaled, i.e. :class:`~.LogBase` for a logarithmic numberline. Defaults to :class:`~.LinearBase`. font_size     The size of the label mobjects. Defaults to 36. label_direction     The specific position to which label mobjects are added on the line. label_constructor     Determines the mobject class that will be used to construct the labels of the number line. line_to_number_buff     The distance between the line and the label mobject. decimal_number_config     Arguments that can be passed to :class:`~.numbers.DecimalNumber` to influence number mobjects. numbers_to_exclude     An explicit iterable of numbers to not be added to the number line. numbers_to_include     An explicit iterable of numbers to add to the number line kwargs     Additional arguments to be passed to :class:`~.Line`.   .. note::      Number ranges that include both negative and positive values will be generated     from the 0 point, and may not include a tick at the min / max     values as the tick locations are dependent on the step size.  Examples -------- .. manim:: NumberLineExample     :save_last_frame:      class NumberLineExample(Scene):         def construct(self):             l0 = NumberLine(                 x_range=[-10, 10, 2],                 length=10,                 color=BLUE,                 include_numbers=True,                 label_direction=UP,             )              l1 = NumberLine(                 x_range=[-10, 10, 2],                 unit_size=0.5,                 numbers_with_elongated_ticks=[-2, 4],                 include_numbers=True,                 font_size=24,             )             num6 = l1.numbers[8]             num6.set_color(RED)              l2 = NumberLine(                 x_range=[-2.5, 2.5 + 0.5, 0.5],                 length=12,                 decimal_number_config={""num_decimal_places"": 2},                 include_numbers=True,             )              l3 = NumberLine(                 x_range=[-5, 5 + 1, 1],                 length=6,                 include_tip=True,                 include_numbers=True,                 rotation=10 * DEGREES,             )              line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)             self.add(line_group)"
BarChart,manim.mobject.graphing.probability,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/probability.py,"Creates a bar chart. Inherits from :class:`~.Axes`, so it shares its methods and attributes. Each axis inherits from :class:`~.NumberLine`, so pass in ``x_axis_config``/``y_axis_config`` to control their attributes.  Parameters ---------- values     A sequence of values that determines the height of each bar. Accepts negative values. bar_names     A sequence of names for each bar. Does not have to match the length of ``values``. y_range     The y_axis range of values. If ``None``, the range will be calculated based on the     min/max of ``values`` and the step will be calculated based on ``y_length``. x_length     The length of the x-axis. If ``None``, it is automatically calculated based on     the number of values and the width of the screen. y_length     The length of the y-axis. bar_colors     The color for the bars. Accepts a sequence of colors (can contain just one item).     If the length of``bar_colors`` does not match that of ``values``,     intermediate colors will be automatically determined. bar_width     The length of a bar. Must be between 0 and 1. bar_fill_opacity     The fill opacity of the bars. bar_stroke_width     The stroke width of the bars.  Examples -------- .. manim:: BarChartExample     :save_last_frame:      class BarChartExample(Scene):         def construct(self):             chart = BarChart(                 values=[-5, 40, -10, 20, -3],                 bar_names=[""one"", ""two"", ""three"", ""four"", ""five""],                 y_range=[-20, 50, 10],                 y_length=6,                 x_length=10,                 x_axis_config={""font_size"": 36},             )              c_bar_lbls = chart.get_bar_labels(font_size=48)              self.add(chart, c_bar_lbls)"
SampleSpace,manim.mobject.graphing.probability,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/graphing/probability.py,"A mobject representing a twodimensional rectangular sampling space.  Examples -------- .. manim:: ExampleSampleSpace     :save_last_frame:      class ExampleSampleSpace(Scene):         def construct(self):             poly1 = SampleSpace(stroke_width=15, fill_opacity=1)             poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)             poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)             poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)             poly_group = VGroup(poly1, poly2, poly3).arrange()             self.add(poly_group)"
ManimBanner,manim.mobject.logo,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/logo.py,"Convenience class representing Manim's banner.  Can be animated using custom methods.  Parameters ---------- dark_theme     If ``True`` (the default), the dark theme version of the logo     (with light text font) will be rendered. Otherwise, if ``False``,     the light theme version (with dark text font) is used.  Examples -------- .. manim:: DarkThemeBanner      class DarkThemeBanner(Scene):         def construct(self):             banner = ManimBanner()             self.play(banner.create())             self.play(banner.expand())             self.wait()             self.play(Unwrite(banner))  .. manim:: LightThemeBanner      class LightThemeBanner(Scene):         def construct(self):             self.camera.background_color = ""#ece6e2""             banner = ManimBanner(dark_theme=False)             self.play(banner.create())             self.play(banner.expand())             self.wait()             self.play(Unwrite(banner))"
DecimalMatrix,manim.mobject.matrix,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/matrix.py,"A mobject that displays a matrix with decimal entries on the screen.  Examples --------  .. manim:: DecimalMatrixExample     :save_last_frame:      class DecimalMatrixExample(Scene):         def construct(self):             m0 = DecimalMatrix(                 [[3.456, 2.122], [33.2244, 12]],                 element_to_mobject_config={""num_decimal_places"": 2},                 left_bracket=""\\{"",                 right_bracket=""\\}"")             self.add(m0)"
IntegerMatrix,manim.mobject.matrix,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/matrix.py,"A mobject that displays a matrix with integer entries on the screen.  Examples --------  .. manim:: IntegerMatrixExample     :save_last_frame:      class IntegerMatrixExample(Scene):         def construct(self):             m0 = IntegerMatrix(                 [[3.7, 2], [42.2, 12]],                 left_bracket=""("",                 right_bracket="")"")             self.add(m0)"
Matrix,manim.mobject.matrix,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/matrix.py,"A mobject that displays a matrix on the screen.  Parameters ---------- matrix     A numpy 2d array or list of lists. v_buff     Vertical distance between elements, by default 0.8. h_buff     Horizontal distance between elements, by default 1.3. bracket_h_buff     Distance of the brackets from the matrix, by default ``MED_SMALL_BUFF``. bracket_v_buff     Height of the brackets, by default ``MED_SMALL_BUFF``. add_background_rectangles_to_entries     ``True`` if should add backgraound rectangles to entries, by default ``False``. include_background_rectangle     ``True`` if should include background rectangle, by default ``False``. element_to_mobject     The mobject class used to construct the elements, by default :class:`~.MathTex`. element_to_mobject_config     Additional arguments to be passed to the constructor in ``element_to_mobject``,     by default ``{}``. element_alignment_corner     The corner to which elements are aligned, by default ``DR``. left_bracket     The left bracket type, by default ``""[""``. right_bracket     The right bracket type, by default ``""]""``. stretch_brackets     ``True`` if should stretch the brackets to fit the height of matrix contents, by default ``True``. bracket_config     Additional arguments to be passed to :class:`~.MathTex` when constructing     the brackets.  Examples -------- The first example shows a variety of uses of this module while the second example exlpains the use of the options `add_background_rectangles_to_entries` and `include_background_rectangle`.  .. manim:: MatrixExamples     :save_last_frame:      class MatrixExamples(Scene):         def construct(self):             m0 = Matrix([[2, r""\pi""], [-1, 1]])             m1 = Matrix([[2, 0, 4], [-1, 1, 5]],                 v_buff=1.3,                 h_buff=0.8,                 bracket_h_buff=SMALL_BUFF,                 bracket_v_buff=SMALL_BUFF,                 left_bracket=r""\{"",                 right_bracket=r""\}"")             m1.add(SurroundingRectangle(m1.get_columns()[1]))             m2 = Matrix([[2, 1], [-1, 3]],                 element_alignment_corner=UL,                 left_bracket=""("",                 right_bracket="")"")             m3 = Matrix([[2, 1], [-1, 3]],                 left_bracket=r""\langle"",                 right_bracket=r""\rangle"")             m4 = Matrix([[2, 1], [-1, 3]],             ).set_column_colors(RED, GREEN)             m5 = Matrix([[2, 1], [-1, 3]],             ).set_row_colors(RED, GREEN)             g = Group(                 m0,m1,m2,m3,m4,m5             ).arrange_in_grid(buff=2)             self.add(g)  .. manim:: BackgroundRectanglesExample     :save_last_frame:      class BackgroundRectanglesExample(Scene):         def construct(self):             background= Rectangle().scale(3.2)             background.set_fill(opacity=.5)             background.set_color([TEAL, RED, YELLOW])             self.add(background)             m0 = Matrix([[12, -30], [-1, 15]],                 add_background_rectangles_to_entries=True)             m1 = Matrix([[2, 0], [-1, 1]],                 include_background_rectangle=True)             m2 = Matrix([[12, -30], [-1, 15]])             g = Group(m0, m1, m2).arrange(buff=2)             self.add(g)"
MobjectMatrix,manim.mobject.matrix,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/matrix.py,"A mobject that displays a matrix of mobject entries on the screen.  Examples --------  .. manim:: MobjectMatrixExample     :save_last_frame:      class MobjectMatrixExample(Scene):         def construct(self):             a = Circle().scale(0.3)             b = Square().scale(0.3)             c = MathTex(""\\pi"").scale(2)             d = Star().scale(0.3)             m0 = MobjectMatrix([[a, b], [c, d]])             self.add(m0)"
Group,manim.mobject.mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/mobject.py,"Groups together multiple :class:`Mobjects <.Mobject>`.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group."
Group,manim.mobject.mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/mobject.py,"Groups together multiple :class:`Mobjects <.Mobject>`.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group."
ArcBrace,manim.mobject.svg.brace,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/brace.py,"Creates a :class:`~Brace` that wraps around an :class:`~.Arc`.  The direction parameter allows the brace to be applied from outside or inside the arc.  .. warning::     The :class:`ArcBrace` is smaller for arcs with smaller radii.  .. note::     The :class:`ArcBrace` is initially a vertical :class:`Brace` defined by the     length of the :class:`~.Arc`, but is scaled down to match the start and end     angles. An exponential function is then applied after it is shifted based on     the radius of the arc.      The scaling effect is not applied for arcs with radii smaller than 1 to prevent     over-scaling.  Parameters ---------- arc     The :class:`~.Arc` that wraps around the :class:`Brace` mobject. direction     The direction from which the brace faces the arc.     ``LEFT`` for inside the arc, and ``RIGHT`` for the outside.  Example -------     .. manim:: ArcBraceExample         :save_last_frame:         :ref_classes: Arc          class ArcBraceExample(Scene):             def construct(self):                 arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)                 brace_1 = ArcBrace(arc_1,LEFT)                 group_1 = VGroup(arc_1,brace_1)                  arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)                 brace_2 = ArcBrace(arc_2)                 group_2 = VGroup(arc_2,brace_2)                  arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)                 brace_3 = ArcBrace(arc_3)                 group_3 = VGroup(arc_3,brace_3)                  arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)                 brace_4 = ArcBrace(arc_4)                 group_4 = VGroup(arc_4,brace_4)                  arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)                 self.add(arc_group.center())"
Brace,manim.mobject.svg.brace,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/brace.py,"Takes a mobject and draws a brace adjacent to it.  Passing a direction vector determines the direction from which the brace is drawn. By default it is drawn from below.  Parameters ---------- mobject     The mobject adjacent to which the brace is placed. direction :     The direction from which the brace faces the mobject.  See Also -------- :class:`BraceBetweenPoints`  Examples -------- .. manim:: BraceExample     :save_last_frame:      class BraceExample(Scene):         def construct(self):             s = Square()             self.add(s)             for i in np.linspace(0.1,1.0,4):                 br = Brace(s, sharpness=i)                 t = Text(f""sharpness= {i}"").next_to(br, RIGHT)                 self.add(t)                 self.add(br)             VGroup(*self.mobjects).arrange(DOWN, buff=0.2)"
Brace,manim.mobject.svg.brace,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/brace.py,"Takes a mobject and draws a brace adjacent to it.  Passing a direction vector determines the direction from which the brace is drawn. By default it is drawn from below.  Parameters ---------- mobject     The mobject adjacent to which the brace is placed. direction :     The direction from which the brace faces the mobject.  See Also -------- :class:`BraceBetweenPoints`  Examples -------- .. manim:: BraceExample     :save_last_frame:      class BraceExample(Scene):         def construct(self):             s = Square()             self.add(s)             for i in np.linspace(0.1,1.0,4):                 br = Brace(s, sharpness=i)                 t = Text(f""sharpness= {i}"").next_to(br, RIGHT)                 self.add(t)                 self.add(br)             VGroup(*self.mobjects).arrange(DOWN, buff=0.2)"
BraceBetweenPoints,manim.mobject.svg.brace,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/brace.py,"Similar to Brace, but instead of taking a mobject it uses 2 points to place the brace.  A fitting direction for the brace is computed, but it still can be manually overridden. If the points go from left to right, the brace is drawn from below. Swapping the points places the brace on the opposite side.  Parameters ---------- point_1 :     The first point. point_2 :     The second point. direction :     The direction from which the brace faces towards the points.  Examples --------     .. manim:: BraceBPExample          class BraceBPExample(Scene):             def construct(self):                 p1 = [0,0,0]                 p2 = [1,2,0]                 brace = BraceBetweenPoints(p1,p2)                 self.play(Create(NumberPlane()))                 self.play(Create(brace))                 self.wait(2)"
BraceLabel,manim.mobject.svg.brace,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/brace.py,"Create a brace with a label attached.  Parameters ---------- obj     The mobject adjacent to which the brace is placed. text     The label text. brace_direction     The direction of the brace. By default ``DOWN``. label_constructor     A class or function used to construct a mobject representing     the label. By default :class:`~.MathTex`. font_size     The font size of the label, passed to the ``label_constructor``. buff     The buffer between the mobject and the brace. brace_config     Arguments to be passed to :class:`.Brace`. kwargs     Additional arguments to be passed to :class:`~.VMobject`."
BraceText,manim.mobject.svg.brace,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/brace.py,"Create a brace with a label attached.  Parameters ---------- obj     The mobject adjacent to which the brace is placed. text     The label text. brace_direction     The direction of the brace. By default ``DOWN``. label_constructor     A class or function used to construct a mobject representing     the label. By default :class:`~.MathTex`. font_size     The font size of the label, passed to the ``label_constructor``. buff     The buffer between the mobject and the brace. brace_config     Arguments to be passed to :class:`.Brace`. kwargs     Additional arguments to be passed to :class:`~.VMobject`."
SVGMobject,manim.mobject.svg.svg_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/svg_mobject.py,"A vectorized mobject created from importing an SVG file.  Parameters ---------- file_name     The path to the SVG file. should_center     Whether or not the mobject should be centered after     being imported. height     The target height of the mobject, set to 2 Manim units by default.     If the height and width are both set to ``None``, the mobject     is imported without being scaled. width     The target width of the mobject, set to ``None`` by default. If     the height and the width are both set to ``None``, the mobject     is imported without being scaled. color     The color (both fill and stroke color) of the mobject. If     ``None`` (the default), the colors set in the SVG file     are used. opacity     The opacity (both fill and stroke opacity) of the mobject.     If ``None`` (the default), the opacity set in the SVG file     is used. fill_color     The fill color of the mobject. If ``None`` (the default),     the fill colors set in the SVG file are used. fill_opacity     The fill opacity of the mobject. If ``None`` (the default),     the fill opacities set in the SVG file are used. stroke_color     The stroke color of the mobject. If ``None`` (the default),     the stroke colors set in the SVG file are used. stroke_opacity     The stroke opacity of the mobject. If ``None`` (the default),     the stroke opacities set in the SVG file are used. stroke_width     The stroke width of the mobject. If ``None`` (the default),     the stroke width values set in the SVG file are used. svg_default     A dictionary in which fallback values for unspecified     properties of elements in the SVG file are defined. If     ``None`` (the default), ``color``, ``opacity``, ``fill_color``     ``fill_opacity``, ``stroke_color``, and ``stroke_opacity``     are set to ``None``, and ``stroke_width`` is set to 0. path_string_config     A dictionary with keyword arguments passed to     :class:`.VMobjectFromSVGPath` used for importing path elements.     If ``None`` (the default), no additional arguments are passed. use_svg_cache     If True (default), the svg inputs (e.g. file_name, settings)     will be used as a key and a copy of the created mobject will     be saved using that key to be quickly retrieved if the same     inputs need be processed later. For large SVGs which are used     only once, this can be omitted to improve performance. kwargs     Further arguments passed to the parent class."
SVGMobject,manim.mobject.svg.svg_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/svg_mobject.py,"A vectorized mobject created from importing an SVG file.  Parameters ---------- file_name     The path to the SVG file. should_center     Whether or not the mobject should be centered after     being imported. height     The target height of the mobject, set to 2 Manim units by default.     If the height and width are both set to ``None``, the mobject     is imported without being scaled. width     The target width of the mobject, set to ``None`` by default. If     the height and the width are both set to ``None``, the mobject     is imported without being scaled. color     The color (both fill and stroke color) of the mobject. If     ``None`` (the default), the colors set in the SVG file     are used. opacity     The opacity (both fill and stroke opacity) of the mobject.     If ``None`` (the default), the opacity set in the SVG file     is used. fill_color     The fill color of the mobject. If ``None`` (the default),     the fill colors set in the SVG file are used. fill_opacity     The fill opacity of the mobject. If ``None`` (the default),     the fill opacities set in the SVG file are used. stroke_color     The stroke color of the mobject. If ``None`` (the default),     the stroke colors set in the SVG file are used. stroke_opacity     The stroke opacity of the mobject. If ``None`` (the default),     the stroke opacities set in the SVG file are used. stroke_width     The stroke width of the mobject. If ``None`` (the default),     the stroke width values set in the SVG file are used. svg_default     A dictionary in which fallback values for unspecified     properties of elements in the SVG file are defined. If     ``None`` (the default), ``color``, ``opacity``, ``fill_color``     ``fill_opacity``, ``stroke_color``, and ``stroke_opacity``     are set to ``None``, and ``stroke_width`` is set to 0. path_string_config     A dictionary with keyword arguments passed to     :class:`.VMobjectFromSVGPath` used for importing path elements.     If ``None`` (the default), no additional arguments are passed. use_svg_cache     If True (default), the svg inputs (e.g. file_name, settings)     will be used as a key and a copy of the created mobject will     be saved using that key to be quickly retrieved if the same     inputs need be processed later. For large SVGs which are used     only once, this can be omitted to improve performance. kwargs     Further arguments passed to the parent class."
SVGMobject,manim.mobject.svg.svg_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/svg_mobject.py,"A vectorized mobject created from importing an SVG file.  Parameters ---------- file_name     The path to the SVG file. should_center     Whether or not the mobject should be centered after     being imported. height     The target height of the mobject, set to 2 Manim units by default.     If the height and width are both set to ``None``, the mobject     is imported without being scaled. width     The target width of the mobject, set to ``None`` by default. If     the height and the width are both set to ``None``, the mobject     is imported without being scaled. color     The color (both fill and stroke color) of the mobject. If     ``None`` (the default), the colors set in the SVG file     are used. opacity     The opacity (both fill and stroke opacity) of the mobject.     If ``None`` (the default), the opacity set in the SVG file     is used. fill_color     The fill color of the mobject. If ``None`` (the default),     the fill colors set in the SVG file are used. fill_opacity     The fill opacity of the mobject. If ``None`` (the default),     the fill opacities set in the SVG file are used. stroke_color     The stroke color of the mobject. If ``None`` (the default),     the stroke colors set in the SVG file are used. stroke_opacity     The stroke opacity of the mobject. If ``None`` (the default),     the stroke opacities set in the SVG file are used. stroke_width     The stroke width of the mobject. If ``None`` (the default),     the stroke width values set in the SVG file are used. svg_default     A dictionary in which fallback values for unspecified     properties of elements in the SVG file are defined. If     ``None`` (the default), ``color``, ``opacity``, ``fill_color``     ``fill_opacity``, ``stroke_color``, and ``stroke_opacity``     are set to ``None``, and ``stroke_width`` is set to 0. path_string_config     A dictionary with keyword arguments passed to     :class:`.VMobjectFromSVGPath` used for importing path elements.     If ``None`` (the default), no additional arguments are passed. use_svg_cache     If True (default), the svg inputs (e.g. file_name, settings)     will be used as a key and a copy of the created mobject will     be saved using that key to be quickly retrieved if the same     inputs need be processed later. For large SVGs which are used     only once, this can be omitted to improve performance. kwargs     Further arguments passed to the parent class."
VMobjectFromSVGPath,manim.mobject.svg.svg_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/svg_mobject.py,"A vectorized mobject representing an SVG path.  .. note::      The ``long_lines``, ``should_subdivide_sharp_curves``,     and ``should_remove_null_curves`` keyword arguments are     only respected with the OpenGL renderer.  Parameters ---------- path_obj     A parsed SVG path object. long_lines     Whether or not straight lines in the vectorized mobject     are drawn in one or two segments. should_subdivide_sharp_curves     Whether or not to subdivide subcurves further in case     two segments meet at an angle that is sharper than a     given threshold. should_remove_null_curves     Whether or not to remove subcurves of length 0. kwargs     Further keyword arguments are passed to the parent     class."
VMobjectFromSVGPath,manim.mobject.svg.svg_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/svg_mobject.py,"A vectorized mobject representing an SVG path.  .. note::      The ``long_lines``, ``should_subdivide_sharp_curves``,     and ``should_remove_null_curves`` keyword arguments are     only respected with the OpenGL renderer.  Parameters ---------- path_obj     A parsed SVG path object. long_lines     Whether or not straight lines in the vectorized mobject     are drawn in one or two segments. should_subdivide_sharp_curves     Whether or not to subdivide subcurves further in case     two segments meet at an angle that is sharper than a     given threshold. should_remove_null_curves     Whether or not to remove subcurves of length 0. kwargs     Further keyword arguments are passed to the parent     class."
VMobjectFromSVGPath,manim.mobject.svg.svg_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/svg/svg_mobject.py,"A vectorized mobject representing an SVG path.  .. note::      The ``long_lines``, ``should_subdivide_sharp_curves``,     and ``should_remove_null_curves`` keyword arguments are     only respected with the OpenGL renderer.  Parameters ---------- path_obj     A parsed SVG path object. long_lines     Whether or not straight lines in the vectorized mobject     are drawn in one or two segments. should_subdivide_sharp_curves     Whether or not to subdivide subcurves further in case     two segments meet at an angle that is sharper than a     given threshold. should_remove_null_curves     Whether or not to remove subcurves of length 0. kwargs     Further keyword arguments are passed to the parent     class."
DecimalTable,manim.mobject.table,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/table.py,"A specialized :class:`~.Table` mobject for use with :class:`~.DecimalNumber` to display decimal entries.  Examples --------  .. manim:: DecimalTableExample     :save_last_frame:      class DecimalTableExample(Scene):         def construct(self):             x_vals = [-2,-1,0,1,2]             y_vals = np.exp(x_vals)             t0 = DecimalTable(                 [x_vals, y_vals],                 row_labels=[MathTex(""x""), MathTex(""f(x)=e^{x}"")],                 h_buff=1,                 element_to_mobject_config={""num_decimal_places"": 2})             self.add(t0)"
IntegerTable,manim.mobject.table,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/table.py,"A specialized :class:`~.Table` mobject for use with :class:`~.Integer`.  Examples --------  .. manim:: IntegerTableExample     :save_last_frame:      class IntegerTableExample(Scene):         def construct(self):             t0 = IntegerTable(                 [[0,30,45,60,90],                 [90,60,45,30,0]],                 col_labels=[                     MathTex(r""\frac{\sqrt{0}}{2}""),                     MathTex(r""\frac{\sqrt{1}}{2}""),                     MathTex(r""\frac{\sqrt{2}}{2}""),                     MathTex(r""\frac{\sqrt{3}}{2}""),                     MathTex(r""\frac{\sqrt{4}}{2}"")],                 row_labels=[MathTex(r""\sin""), MathTex(r""\cos"")],                 h_buff=1,                 element_to_mobject_config={""unit"": r""^{\circ}""})             self.add(t0)"
MathTable,manim.mobject.table,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/table.py,"A specialized :class:`~.Table` mobject for use with LaTeX.  Examples --------  .. manim:: MathTableExample     :save_last_frame:      class MathTableExample(Scene):         def construct(self):             t0 = MathTable(                 [[""+"", 0, 5, 10],                 [0, 0, 5, 10],                 [2, 2, 7, 12],                 [4, 4, 9, 14]],                 include_outer_lines=True)             self.add(t0)"
MobjectTable,manim.mobject.table,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/table.py,"A specialized :class:`~.Table` mobject for use with :class:`~.Mobject`.  Examples --------  .. manim:: MobjectTableExample     :save_last_frame:      class MobjectTableExample(Scene):         def construct(self):             cross = VGroup(                 Line(UP + LEFT, DOWN + RIGHT),                 Line(UP + RIGHT, DOWN + LEFT),             )             a = Circle().set_color(RED).scale(0.5)             b = cross.set_color(BLUE).scale(0.5)             t0 = MobjectTable(                 [[a.copy(),b.copy(),a.copy()],                 [b.copy(),a.copy(),a.copy()],                 [a.copy(),b.copy(),b.copy()]]             )             line = Line(                 t0.get_corner(DL), t0.get_corner(UR)             ).set_color(RED)             self.add(t0, line)"
Table,manim.mobject.table,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/table.py,"A mobject that displays a table on the screen.  Parameters ---------- table     A 2D array or list of lists. Content of the table has to be a valid input     for the callable set in ``element_to_mobject``. row_labels     List of :class:`~.VMobject` representing the labels of each row. col_labels     List of :class:`~.VMobject` representing the labels of each column. top_left_entry     The top-left entry of the table, can only be specified if row and     column labels are given. v_buff     Vertical buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 0.8. h_buff     Horizontal buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 1.3. include_outer_lines     ``True`` if the table should include outer lines, by default False. add_background_rectangles_to_entries     ``True`` if background rectangles should be added to entries, by default ``False``. entries_background_color     Background color of entries if ``add_background_rectangles_to_entries`` is ``True``. include_background_rectangle     ``True`` if the table should have a background rectangle, by default ``False``. background_rectangle_color     Background color of table if ``include_background_rectangle`` is ``True``. element_to_mobject     The :class:`~.Mobject` class applied to the table entries. by default :class:`~.Paragraph`. For common choices, see :mod:`~.text_mobject`/:mod:`~.tex_mobject`. element_to_mobject_config     Custom configuration passed to :attr:`element_to_mobject`, by default {}. arrange_in_grid_config     Dict passed to :meth:`~.Mobject.arrange_in_grid`, customizes the arrangement of the table. line_config     Dict passed to :class:`~.Line`, customizes the lines of the table. kwargs     Additional arguments to be passed to :class:`~.VGroup`.  Examples --------  .. manim:: TableExamples     :save_last_frame:      class TableExamples(Scene):         def construct(self):             t0 = Table(                 [[""This"", ""is a""],                 [""simple"", ""Table in \\n Manim.""]])             t1 = Table(                 [[""This"", ""is a""],                 [""simple"", ""Table.""]],                 row_labels=[Text(""R1""), Text(""R2"")],                 col_labels=[Text(""C1""), Text(""C2"")])             t1.add_highlighted_cell((2,2), color=YELLOW)             t2 = Table(                 [[""This"", ""is a""],                 [""simple"", ""Table.""]],                 row_labels=[Text(""R1""), Text(""R2"")],                 col_labels=[Text(""C1""), Text(""C2"")],                 top_left_entry=Star().scale(0.3),                 include_outer_lines=True,                 arrange_in_grid_config={""cell_alignment"": RIGHT})             t2.add(t2.get_cell((2,2), color=RED))             t3 = Table(                 [[""This"", ""is a""],                 [""simple"", ""Table.""]],                 row_labels=[Text(""R1""), Text(""R2"")],                 col_labels=[Text(""C1""), Text(""C2"")],                 top_left_entry=Star().scale(0.3),                 include_outer_lines=True,                 line_config={""stroke_width"": 1, ""color"": YELLOW})             t3.remove(*t3.get_vertical_lines())             g = Group(                 t0,t1,t2,t3             ).scale(0.7).arrange_in_grid(buff=1)             self.add(g)  .. manim:: BackgroundRectanglesExample     :save_last_frame:      class BackgroundRectanglesExample(Scene):         def construct(self):             background = Rectangle(height=6.5, width=13)             background.set_fill(opacity=.5)             background.set_color([TEAL, RED, YELLOW])             self.add(background)             t0 = Table(                 [[""This"", ""is a""],                 [""simple"", ""Table.""]],                 add_background_rectangles_to_entries=True)             t1 = Table(                 [[""This"", ""is a""],                 [""simple"", ""Table.""]],                 include_background_rectangle=True)             g = Group(t0, t1).scale(0.7).arrange(buff=0.5)             self.add(g)"
Code,manim.mobject.text.code_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/code_mobject.py,"A highlighted source code listing.  Examples --------  Normal usage::      listing = Code(         ""helloworldcpp.cpp"",         tab_width=4,         formatter_style=""emacs"",         background=""window"",         language=""cpp"",         background_config={""stroke_color"": WHITE},         paragraph_config={""font"": ""Noto Sans Mono""},     )  We can also render code passed as a string. As the automatic language detection can be a bit flaky, it is recommended to specify the language explicitly:  .. manim:: CodeFromString     :save_last_frame:      class CodeFromString(Scene):         def construct(self):             code = '''from manim import Scene, Square      class FadeInSquare(Scene):         def construct(self):             s = Square()             self.play(FadeIn(s))             self.play(s.animate.scale(2))             self.wait()'''              rendered_code = Code(                 code_string=code,                 language=""python"",                 background=""window"",                 background_config={""stroke_color"": ""maroon""},             )             self.add(rendered_code)  Parameters ---------- code_file     The path to the code file to display. code_string     Alternatively, the code string to display. language     The programming language of the code. If not specified, it will be     guessed from the file extension or the code itself. formatter_style     The style to use for the code highlighting. Defaults to ``""vim""``.     A list of all available styles can be obtained by calling     :meth:`.Code.get_styles_list`. tab_width     The width of a tab character in spaces. Defaults to 4. add_line_numbers     Whether to display line numbers. Defaults to ``True``. line_numbers_from     The first line number to display. Defaults to 1. background     The type of background to use. Can be either ``""rectangle""`` (the     default) or ``""window""``. background_config     Keyword arguments passed to the background constructor. Default     settings are stored in the class attribute     :attr:`.default_background_config` (which can also be modified     directly). paragraph_config     Keyword arguments passed to the constructor of the     :class:`.Paragraph` objects holding the code, and the line     numbers. Default settings are stored in the class attribute     :attr:`.default_paragraph_config` (which can also be modified     directly)."
DecimalNumber,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"An mobject representing a decimal number.  Parameters ---------- number     The numeric value to be displayed. It can later be modified using :meth:`.set_value`. num_decimal_places     The number of decimal places after the decimal separator. Values are automatically rounded. mob_class     The class for rendering digits and units, by default :class:`.MathTex`. include_sign     Set to ``True`` to include a sign for positive numbers and zero. group_with_commas     When ``True`` thousands groups are separated by commas for readability. digit_buff_per_font_unit     Additional spacing between digits. Scales with font size. show_ellipsis     When a number has been truncated by rounding, indicate with an ellipsis (``...``). unit     A unit string which can be placed to the right of the numerical values. unit_buff_per_font_unit     An additional spacing between the numerical values and the unit. A value     of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size. include_background_rectangle     Adds a background rectangle to increase contrast on busy scenes. edge_to_fix     Assuring right- or left-alignment of the full object. font_size     Size of the font.  Examples --------  .. manim:: MovingSquareWithUpdaters      class MovingSquareWithUpdaters(Scene):         def construct(self):             decimal = DecimalNumber(                 0,                 show_ellipsis=True,                 num_decimal_places=3,                 include_sign=True,                 unit=r""\text{M-Units}"",                 unit_buff_per_font_unit=0.003             )             square = Square().to_edge(UP)              decimal.add_updater(lambda d: d.next_to(square, RIGHT))             decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))             self.add(square, decimal)             self.play(                 square.animate.to_edge(DOWN),                 rate_func=there_and_back,                 run_time=5,             )             self.wait()"
DecimalNumber,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"An mobject representing a decimal number.  Parameters ---------- number     The numeric value to be displayed. It can later be modified using :meth:`.set_value`. num_decimal_places     The number of decimal places after the decimal separator. Values are automatically rounded. mob_class     The class for rendering digits and units, by default :class:`.MathTex`. include_sign     Set to ``True`` to include a sign for positive numbers and zero. group_with_commas     When ``True`` thousands groups are separated by commas for readability. digit_buff_per_font_unit     Additional spacing between digits. Scales with font size. show_ellipsis     When a number has been truncated by rounding, indicate with an ellipsis (``...``). unit     A unit string which can be placed to the right of the numerical values. unit_buff_per_font_unit     An additional spacing between the numerical values and the unit. A value     of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size. include_background_rectangle     Adds a background rectangle to increase contrast on busy scenes. edge_to_fix     Assuring right- or left-alignment of the full object. font_size     Size of the font.  Examples --------  .. manim:: MovingSquareWithUpdaters      class MovingSquareWithUpdaters(Scene):         def construct(self):             decimal = DecimalNumber(                 0,                 show_ellipsis=True,                 num_decimal_places=3,                 include_sign=True,                 unit=r""\text{M-Units}"",                 unit_buff_per_font_unit=0.003             )             square = Square().to_edge(UP)              decimal.add_updater(lambda d: d.next_to(square, RIGHT))             decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))             self.add(square, decimal)             self.play(                 square.animate.to_edge(DOWN),                 rate_func=there_and_back,                 run_time=5,             )             self.wait()"
DecimalNumber,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"An mobject representing a decimal number.  Parameters ---------- number     The numeric value to be displayed. It can later be modified using :meth:`.set_value`. num_decimal_places     The number of decimal places after the decimal separator. Values are automatically rounded. mob_class     The class for rendering digits and units, by default :class:`.MathTex`. include_sign     Set to ``True`` to include a sign for positive numbers and zero. group_with_commas     When ``True`` thousands groups are separated by commas for readability. digit_buff_per_font_unit     Additional spacing between digits. Scales with font size. show_ellipsis     When a number has been truncated by rounding, indicate with an ellipsis (``...``). unit     A unit string which can be placed to the right of the numerical values. unit_buff_per_font_unit     An additional spacing between the numerical values and the unit. A value     of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size. include_background_rectangle     Adds a background rectangle to increase contrast on busy scenes. edge_to_fix     Assuring right- or left-alignment of the full object. font_size     Size of the font.  Examples --------  .. manim:: MovingSquareWithUpdaters      class MovingSquareWithUpdaters(Scene):         def construct(self):             decimal = DecimalNumber(                 0,                 show_ellipsis=True,                 num_decimal_places=3,                 include_sign=True,                 unit=r""\text{M-Units}"",                 unit_buff_per_font_unit=0.003             )             square = Square().to_edge(UP)              decimal.add_updater(lambda d: d.next_to(square, RIGHT))             decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))             self.add(square, decimal)             self.play(                 square.animate.to_edge(DOWN),                 rate_func=there_and_back,                 run_time=5,             )             self.wait()"
DecimalNumber,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"An mobject representing a decimal number.  Parameters ---------- number     The numeric value to be displayed. It can later be modified using :meth:`.set_value`. num_decimal_places     The number of decimal places after the decimal separator. Values are automatically rounded. mob_class     The class for rendering digits and units, by default :class:`.MathTex`. include_sign     Set to ``True`` to include a sign for positive numbers and zero. group_with_commas     When ``True`` thousands groups are separated by commas for readability. digit_buff_per_font_unit     Additional spacing between digits. Scales with font size. show_ellipsis     When a number has been truncated by rounding, indicate with an ellipsis (``...``). unit     A unit string which can be placed to the right of the numerical values. unit_buff_per_font_unit     An additional spacing between the numerical values and the unit. A value     of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size. include_background_rectangle     Adds a background rectangle to increase contrast on busy scenes. edge_to_fix     Assuring right- or left-alignment of the full object. font_size     Size of the font.  Examples --------  .. manim:: MovingSquareWithUpdaters      class MovingSquareWithUpdaters(Scene):         def construct(self):             decimal = DecimalNumber(                 0,                 show_ellipsis=True,                 num_decimal_places=3,                 include_sign=True,                 unit=r""\text{M-Units}"",                 unit_buff_per_font_unit=0.003             )             square = Square().to_edge(UP)              decimal.add_updater(lambda d: d.next_to(square, RIGHT))             decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))             self.add(square, decimal)             self.play(                 square.animate.to_edge(DOWN),                 rate_func=there_and_back,                 run_time=5,             )             self.wait()"
Integer,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"A class for displaying Integers.  Examples --------  .. manim:: IntegerExample     :save_last_frame:      class IntegerExample(Scene):         def construct(self):             self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))             self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))             self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))             self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))"
Integer,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"A class for displaying Integers.  Examples --------  .. manim:: IntegerExample     :save_last_frame:      class IntegerExample(Scene):         def construct(self):             self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))             self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))             self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))             self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))"
Integer,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"A class for displaying Integers.  Examples --------  .. manim:: IntegerExample     :save_last_frame:      class IntegerExample(Scene):         def construct(self):             self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))             self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))             self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))             self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))"
Integer,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"A class for displaying Integers.  Examples --------  .. manim:: IntegerExample     :save_last_frame:      class IntegerExample(Scene):         def construct(self):             self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))             self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))             self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))             self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))"
Variable,manim.mobject.text.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/numbers.py,"A class for displaying text that shows ""label = value"" with the value continuously updated from a :class:`~.ValueTracker`.  Parameters ---------- var     The initial value you need to keep track of and display. label     The label for your variable. Raw strings are convertex to :class:`~.MathTex` objects. var_type     The class used for displaying the number. Defaults to :class:`DecimalNumber`. num_decimal_places     The number of decimal places to display in your variable. Defaults to 2.     If `var_type` is an :class:`Integer`, this parameter is ignored. kwargs         Other arguments to be passed to `~.Mobject`.  Attributes ---------- label : Union[:class:`str`, :class:`~.Tex`, :class:`~.MathTex`, :class:`~.Text`, :class:`~.SingleStringMathTex`]     The label for your variable, for example ``x = ...``. tracker : :class:`~.ValueTracker`     Useful in updating the value of your variable on-screen. value : Union[:class:`DecimalNumber`, :class:`Integer`]     The tex for the value of your variable.  Examples -------- Normal usage::      # DecimalNumber type     var = 0.5     on_screen_var = Variable(var, Text(""var""), num_decimal_places=3)     # Integer type     int_var = 0     on_screen_int_var = Variable(int_var, Text(""int_var""), var_type=Integer)     # Using math mode for the label     on_screen_int_var = Variable(int_var, ""{a}_{i}"", var_type=Integer)  .. manim:: VariablesWithValueTracker      class VariablesWithValueTracker(Scene):         def construct(self):             var = 0.5             on_screen_var = Variable(var, Text(""var""), num_decimal_places=3)              # You can also change the colours for the label and value             on_screen_var.label.set_color(RED)             on_screen_var.value.set_color(GREEN)              self.play(Write(on_screen_var))             # The above line will just display the variable with             # its initial value on the screen. If you also wish to             # update it, you can do so by accessing the `tracker` attribute             self.wait()             var_tracker = on_screen_var.tracker             var = 10.5             self.play(var_tracker.animate.set_value(var))             self.wait()              int_var = 0             on_screen_int_var = Variable(                 int_var, Text(""int_var""), var_type=Integer             ).next_to(on_screen_var, DOWN)             on_screen_int_var.label.set_color(RED)             on_screen_int_var.value.set_color(GREEN)              self.play(Write(on_screen_int_var))             self.wait()             var_tracker = on_screen_int_var.tracker             var = 10.5             self.play(var_tracker.animate.set_value(var))             self.wait()              # If you wish to have a somewhat more complicated label for your             # variable with subscripts, superscripts, etc. the default class             # for the label is MathTex             subscript_label_var = 10             on_screen_subscript_var = Variable(subscript_label_var, ""{a}_{i}"").next_to(                 on_screen_int_var, DOWN             )             self.play(Write(on_screen_subscript_var))             self.wait()  .. manim:: VariableExample      class VariableExample(Scene):         def construct(self):             start = 2.0              x_var = Variable(start, 'x', num_decimal_places=3)             sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)             Group(x_var, sqr_var).arrange(DOWN)              sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))              self.add(x_var, sqr_var)             self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)             self.wait(0.1)"
BulletedList,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A bulleted list.  Examples --------  .. manim:: BulletedListExample     :save_last_frame:      class BulletedListExample(Scene):         def construct(self):             blist = BulletedList(""Item 1"", ""Item 2"", ""Item 3"", height=2, width=2)             blist.set_color_by_tex(""Item 1"", RED)             blist.set_color_by_tex(""Item 2"", GREEN)             blist.set_color_by_tex(""Item 3"", BLUE)             self.add(blist)"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
MathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A string compiled with LaTeX in math mode.  Examples -------- .. manim:: Formula     :save_last_frame:      class Formula(Scene):         def construct(self):             t = MathTex(r""\int_a^b f'(x) dx = f(b)- f(a)"")             self.add(t)  Tests ----- Check that creating a :class:`~.MathTex` works::      >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP     MathTex('a^2 + b^2 = c^2')  Check that double brace group splitting works correctly::      >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP     >>> len(t1.submobjects) # doctest: +SKIP     5     >>> t2 = MathTex(r""\frac{1}{a+b\sqrt{2}}"") # doctest: +SKIP     >>> len(t2.submobjects) # doctest: +SKIP     1"
SingleStringMathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,Elementary building block for rendering text with LaTeX.  Tests ----- Check that creating a :class:`~.SingleStringMathTex` object works::      >>> SingleStringMathTex('Test') # doctest: +SKIP     SingleStringMathTex('Test')
SingleStringMathTex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,Elementary building block for rendering text with LaTeX.  Tests ----- Check that creating a :class:`~.SingleStringMathTex` object works::      >>> SingleStringMathTex('Test') # doctest: +SKIP     SingleStringMathTex('Test')
Tex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,A string compiled with LaTeX in normal mode.  The color can be set using the ``color`` argument. Any parts of the ``tex_string`` that are colored by the TeX commands ``\color`` or ``\textcolor`` will retain their original color.  Tests -----  Check whether writing a LaTeX string works::      >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP     Tex('The horse does not eat cucumber salad.')
Tex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,A string compiled with LaTeX in normal mode.  The color can be set using the ``color`` argument. Any parts of the ``tex_string`` that are colored by the TeX commands ``\color`` or ``\textcolor`` will retain their original color.  Tests -----  Check whether writing a LaTeX string works::      >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP     Tex('The horse does not eat cucumber salad.')
Tex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,A string compiled with LaTeX in normal mode.  The color can be set using the ``color`` argument. Any parts of the ``tex_string`` that are colored by the TeX commands ``\color`` or ``\textcolor`` will retain their original color.  Tests -----  Check whether writing a LaTeX string works::      >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP     Tex('The horse does not eat cucumber salad.')
Tex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,A string compiled with LaTeX in normal mode.  The color can be set using the ``color`` argument. Any parts of the ``tex_string`` that are colored by the TeX commands ``\color`` or ``\textcolor`` will retain their original color.  Tests -----  Check whether writing a LaTeX string works::      >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP     Tex('The horse does not eat cucumber salad.')
Tex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,A string compiled with LaTeX in normal mode.  The color can be set using the ``color`` argument. Any parts of the ``tex_string`` that are colored by the TeX commands ``\color`` or ``\textcolor`` will retain their original color.  Tests -----  Check whether writing a LaTeX string works::      >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP     Tex('The horse does not eat cucumber salad.')
Tex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,A string compiled with LaTeX in normal mode.  The color can be set using the ``color`` argument. Any parts of the ``tex_string`` that are colored by the TeX commands ``\color`` or ``\textcolor`` will retain their original color.  Tests -----  Check whether writing a LaTeX string works::      >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP     Tex('The horse does not eat cucumber salad.')
Tex,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,A string compiled with LaTeX in normal mode.  The color can be set using the ``color`` argument. Any parts of the ``tex_string`` that are colored by the TeX commands ``\color`` or ``\textcolor`` will retain their original color.  Tests -----  Check whether writing a LaTeX string works::      >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP     Tex('The horse does not eat cucumber salad.')
Title,manim.mobject.text.tex_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/tex_mobject.py,"A mobject representing an underlined title.  Examples -------- .. manim:: TitleExample     :save_last_frame:      import manim      class TitleExample(Scene):         def construct(self):             banner = ManimBanner()             title = Title(f""Manim version {manim.__version__}"")             self.add(banner, title)"
MarkupText,manim.mobject.text.text_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/text_mobject.py,"Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.  Text objects behave like a :class:`.VGroup`-like iterable of all characters in the given text. In particular, slicing is possible.  **What is PangoMarkup?**  PangoMarkup is a small markup language like html and it helps you avoid using ""range of characters"" while coloring or styling a piece a Text. You can use this language with :class:`~.MarkupText`.  A simple example of a marked-up string might be::      <span foreground=""blue"" size=""x-large"">Blue text</span> is <i>cool</i>!""  and it can be used with :class:`~.MarkupText` as  .. manim:: MarkupExample     :save_last_frame:      class MarkupExample(Scene):         def construct(self):             text = MarkupText('<span foreground=""blue"" size=""x-large"">Blue text</span> is <i>cool</i>!""')             self.add(text)  A more elaborate example would be:  .. manim:: MarkupElaborateExample     :save_last_frame:      class MarkupElaborateExample(Scene):         def construct(self):             text = MarkupText(                 '<span foreground=""purple"">ا</span><span foreground=""red"">َ</span>'                 'ل<span foreground=""blue"">ْ</span>ع<span foreground=""red"">َ</span>ر'                 '<span foreground=""red"">َ</span>ب<span foreground=""red"">ِ</span>ي'                 '<span foreground=""green"">ّ</span><span foreground=""red"">َ</span>ة'                 '<span foreground=""blue"">ُ</span>'             )             self.add(text)  PangoMarkup can also contain XML features such as numeric character entities such as ``&#169;`` for © can be used too.  The most general markup tag is ``<span>``, then there are some convenience tags.  Here is a list of supported tags:  - ``<b>bold</b>``, ``<i>italic</i>`` and ``<b><i>bold+italic</i></b>`` - ``<u>underline</u>`` and ``<s>strike through</s>`` - ``<tt>typewriter font</tt>`` - ``<big>bigger font</big>`` and ``<small>smaller font</small>`` - ``<sup>superscript</sup>`` and ``<sub>subscript</sub>`` - ``<span underline=""double"" underline_color=""green"">double underline</span>`` - ``<span underline=""error"">error underline</span>`` - ``<span overline=""single"" overline_color=""green"">overline</span>`` - ``<span strikethrough=""true"" strikethrough_color=""red"">strikethrough</span>`` - ``<span font_family=""sans"">temporary change of font</span>`` - ``<span foreground=""red"">temporary change of color</span>`` - ``<span fgcolor=""red"">temporary change of color</span>`` - ``<gradient from=""YELLOW"" to=""RED"">temporary gradient</gradient>``  For ``<span>`` markup, colors can be specified either as hex triples like ``#aabbcc`` or as named CSS colors like ``AliceBlue``. The ``<gradient>`` tag is handled by Manim rather than Pango, and supports hex triplets or Manim constants like ``RED`` or ``RED_A``. If you want to use Manim constants like ``RED_A`` together with ``<span>``, you will need to use Python's f-String syntax as follows::      MarkupText(f'<span foreground=""{RED_A}"">here you go</span>')  If your text contains ligatures, the :class:`MarkupText` class may incorrectly determine the first and last letter when creating the gradient. This is due to the fact that ``fl`` are two separate characters, but might be set as one single glyph - a ligature. If your language does not depend on ligatures, consider setting ``disable_ligatures`` to ``True``. If you must use ligatures, the ``gradient`` tag supports an optional attribute ``offset`` which can be used to compensate for that error.  For example:  - ``<gradient from=""RED"" to=""YELLOW"" offset=""1"">example</gradient>`` to *start* the gradient one letter earlier - ``<gradient from=""RED"" to=""YELLOW"" offset="",1"">example</gradient>`` to *end* the gradient one letter earlier - ``<gradient from=""RED"" to=""YELLOW"" offset=""2,1"">example</gradient>`` to *start* the gradient two letters earlier and *end* it one letter earlier  Specifying a second offset may be necessary if the text to be colored does itself contain ligatures. The same can happen when using HTML entities for special chars.  When using ``underline``, ``overline`` or ``strikethrough`` together with ``<gradient>`` tags, you will also need to use the offset, because underlines are additional paths in the final :class:`SVGMobject`. Check out the following example.  Escaping of special characters: ``>`` **should** be written as ``&gt;`` whereas ``<`` and ``&`` *must* be written as ``&lt;`` and ``&amp;``.  You can find more information about Pango markup formatting at the corresponding documentation page: `Pango Markup <https://docs.gtk.org/Pango/pango_markup.html>`_. Please be aware that not all features are supported by this class and that the ``<gradient>`` tag mentioned above is not supported by Pango.  Parameters ----------  text     The text that needs to be created as mobject. fill_opacity     The fill opacity, with 1 meaning opaque and 0 meaning transparent. stroke_width     Stroke width. font_size     Font size. line_spacing     Line spacing. font     Global font setting for the entire text. Local overrides are possible. slant     Global slant setting, e.g. `NORMAL` or `ITALIC`. Local overrides are possible. weight     Global weight setting, e.g. `NORMAL` or `BOLD`. Local overrides are possible. gradient     Global gradient setting. Local overrides are possible. warn_missing_font     If True (default), Manim will issue a warning if the font does not exist in the     (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.  Returns ------- :class:`MarkupText`     The text displayed in form of a :class:`.VGroup`-like mobject.  Examples ---------  .. manim:: BasicMarkupExample     :save_last_frame:      class BasicMarkupExample(Scene):         def construct(self):             text1 = MarkupText(""<b>foo</b> <i>bar</i> <b><i>foobar</i></b>"")             text2 = MarkupText(""<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>"")             text3 = MarkupText(""H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>"")             text4 = MarkupText(""type <tt>help</tt> for help"")             text5 = MarkupText(                 '<span underline=""double"">foo</span> <span underline=""error"">bar</span>'             )             group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)             self.add(group)  .. manim:: ColorExample     :save_last_frame:      class ColorExample(Scene):         def construct(self):             text1 = MarkupText(                 f'all in red <span fgcolor=""{YELLOW}"">except this</span>', color=RED             )             text2 = MarkupText(""nice gradient"", gradient=(BLUE, GREEN))             text3 = MarkupText(                 'nice <gradient from=""RED"" to=""YELLOW"">intermediate</gradient> gradient',                 gradient=(BLUE, GREEN),             )             text4 = MarkupText(                 'fl ligature <gradient from=""RED"" to=""YELLOW"">causing trouble</gradient> here'             )             text5 = MarkupText(                 'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1"">defeated</gradient> with offset'             )             text6 = MarkupText(                 'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1"">floating</gradient> inside'             )             text7 = MarkupText(                 'fl ligature <gradient from=""RED"" to=""YELLOW"" offset=""1,1"">floating</gradient> inside'             )             group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)             self.add(group)  .. manim:: UnderlineExample     :save_last_frame:      class UnderlineExample(Scene):         def construct(self):             text1 = MarkupText(                 '<span underline=""double"" underline_color=""green"">bla</span>'             )             text2 = MarkupText(                 '<span underline=""single"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"">aabb</gradient>y'             )             text3 = MarkupText(                 '<span underline=""single"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"" offset=""-1"">aabb</gradient>y'             )             text4 = MarkupText(                 '<span underline=""double"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"">aabb</gradient>y'             )             text5 = MarkupText(                 '<span underline=""double"" underline_color=""green"">xxx</span><gradient from=""#ffff00"" to=""RED"" offset=""-2"">aabb</gradient>y'             )             group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)             self.add(group)  .. manim:: FontExample     :save_last_frame:      class FontExample(Scene):         def construct(self):             text1 = MarkupText(                 'all in sans <span font_family=""serif"">except this</span>', font=""sans""             )             text2 = MarkupText(                 '<span font_family=""serif"">mixing</span> <span font_family=""sans"">fonts</span> <span font_family=""monospace"">is ugly</span>'             )             text3 = MarkupText(""special char > or &gt;"")             text4 = MarkupText(""special char &lt; and &amp;"")             group = VGroup(text1, text2, text3, text4).arrange(DOWN)             self.add(group)  .. manim:: NewlineExample     :save_last_frame:      class NewlineExample(Scene):         def construct(self):             text = MarkupText('foooo<span foreground=""red"">oo\nbaa</span>aar')             self.add(text)  .. manim:: NoLigaturesExample     :save_last_frame:      class NoLigaturesExample(Scene):         def construct(self):             text1 = MarkupText('fl<gradient from=""RED"" to=""GREEN"">oat</gradient>ing')             text2 = MarkupText('fl<gradient from=""RED"" to=""GREEN"">oat</gradient>ing', disable_ligatures=True)             group = VGroup(text1, text2).arrange(DOWN)             self.add(group)   As :class:`MarkupText` uses Pango to render text, rendering non-English characters is easily possible:  .. manim:: MultiLanguage     :save_last_frame:      class MultiLanguage(Scene):         def construct(self):             morning = MarkupText(""வணக்கம்"", font=""sans-serif"")             japanese = MarkupText(                 '<span fgcolor=""blue"">日本</span>へようこそ'             )  # works as in ``Text``.             mess = MarkupText(""Multi-Language"", weight=BOLD)             russ = MarkupText(""Здравствуйте मस नम म "", font=""sans-serif"")             hin = MarkupText(""नमस्ते"", font=""sans-serif"")             chinese = MarkupText(""臂猿「黛比」帶著孩子"", font=""sans-serif"")             group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)             self.add(group)  You can justify the text by passing :attr:`justify` parameter.  .. manim:: JustifyText      class JustifyText(Scene):         def construct(self):             ipsum_text = (                 ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.""                 ""Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere ""                 ""quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam ""                 ""fermentum interdum justo, nec rutrum elit pretium ac. Nam quis ""                 ""leo pulvinar, dignissim est at, venenatis nisi.""             )             justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)             not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)             just_title = Title(""Justified"")             njust_title = Title(""Not Justified"")             self.add(njust_title, not_justified_text)             self.play(                 FadeOut(not_justified_text),                 FadeIn(justified_text),                 FadeOut(njust_title),                 FadeIn(just_title),             )             self.wait(1)  Tests -----  Check that the creation of :class:`~.MarkupText` works::      >>> MarkupText('The horse does not eat cucumber salad.')     MarkupText('The horse does not eat cucumber salad.')"
Paragraph,manim.mobject.text.text_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/text_mobject.py,"Display a paragraph of text.  For a given :class:`.Paragraph` ``par``, the attribute ``par.chars`` is a :class:`.VGroup` containing all the lines. In this context, every line is constructed as a :class:`.VGroup` of characters contained in the line.   Parameters ---------- line_spacing     Represents the spacing between lines. Defaults to -1, which means auto. alignment     Defines the alignment of paragraph. Defaults to None. Possible values are ""left"", ""right"" or ""center"".  Examples -------- Normal usage::      paragraph = Paragraph(         ""this is a awesome"",         ""paragraph"",         ""With \nNewlines"",         ""\tWith Tabs"",         ""  With Spaces"",         ""With Alignments"",         ""center"",         ""left"",         ""right"",     )  Remove unwanted invisible characters::      self.play(Transform(remove_invisible_chars(paragraph.chars[0:2]),                         remove_invisible_chars(paragraph.chars[3][0:3]))"
Paragraph,manim.mobject.text.text_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/text_mobject.py,"Display a paragraph of text.  For a given :class:`.Paragraph` ``par``, the attribute ``par.chars`` is a :class:`.VGroup` containing all the lines. In this context, every line is constructed as a :class:`.VGroup` of characters contained in the line.   Parameters ---------- line_spacing     Represents the spacing between lines. Defaults to -1, which means auto. alignment     Defines the alignment of paragraph. Defaults to None. Possible values are ""left"", ""right"" or ""center"".  Examples -------- Normal usage::      paragraph = Paragraph(         ""this is a awesome"",         ""paragraph"",         ""With \nNewlines"",         ""\tWith Tabs"",         ""  With Spaces"",         ""With Alignments"",         ""center"",         ""left"",         ""right"",     )  Remove unwanted invisible characters::      self.play(Transform(remove_invisible_chars(paragraph.chars[0:2]),                         remove_invisible_chars(paragraph.chars[3][0:3]))"
Paragraph,manim.mobject.text.text_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/text_mobject.py,"Display a paragraph of text.  For a given :class:`.Paragraph` ``par``, the attribute ``par.chars`` is a :class:`.VGroup` containing all the lines. In this context, every line is constructed as a :class:`.VGroup` of characters contained in the line.   Parameters ---------- line_spacing     Represents the spacing between lines. Defaults to -1, which means auto. alignment     Defines the alignment of paragraph. Defaults to None. Possible values are ""left"", ""right"" or ""center"".  Examples -------- Normal usage::      paragraph = Paragraph(         ""this is a awesome"",         ""paragraph"",         ""With \nNewlines"",         ""\tWith Tabs"",         ""  With Spaces"",         ""With Alignments"",         ""center"",         ""left"",         ""right"",     )  Remove unwanted invisible characters::      self.play(Transform(remove_invisible_chars(paragraph.chars[0:2]),                         remove_invisible_chars(paragraph.chars[3][0:3]))"
Text,manim.mobject.text.text_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/text_mobject.py,"Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.  Text objects behave like a :class:`.VGroup`-like iterable of all characters in the given text. In particular, slicing is possible.  Parameters ---------- text     The text that needs to be created as a mobject. font     The font family to be used to render the text. This is either a system font or     one loaded with `register_font()`. Note that font family names may be different     across operating systems. warn_missing_font     If True (default), Manim will issue a warning if the font does not exist in the     (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.  Returns ------- :class:`Text`     The mobject-like :class:`.VGroup`.  Examples ---------  .. manim:: Example1Text     :save_last_frame:      class Example1Text(Scene):         def construct(self):             text = Text('Hello world').scale(3)             self.add(text)  .. manim:: TextColorExample     :save_last_frame:      class TextColorExample(Scene):         def construct(self):             text1 = Text('Hello world', color=BLUE).scale(3)             text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)             self.add(text1, text2)  .. manim:: TextItalicAndBoldExample     :save_last_frame:      class TextItalicAndBoldExample(Scene):         def construct(self):             text1 = Text(""Hello world"", slant=ITALIC)             text2 = Text(""Hello world"", t2s={'world':ITALIC})             text3 = Text(""Hello world"", weight=BOLD)             text4 = Text(""Hello world"", t2w={'world':BOLD})             text5 = Text(""Hello world"", t2c={'o':YELLOW}, disable_ligatures=True)             text6 = Text(                 ""Visit us at docs.manim.community"",                 t2c={""docs.manim.community"": YELLOW},                 disable_ligatures=True,            )             text6.scale(1.3).shift(DOWN)             self.add(text1, text2, text3, text4, text5 , text6)             Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)  .. manim:: TextMoreCustomization         :save_last_frame:          class TextMoreCustomization(Scene):             def construct(self):                 text1 = Text(                     'Google',                     t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',                          '[2:3]': '#fbb003', '[3:4]': '#3174f0',                          '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)                 self.add(text1)  As :class:`Text` uses Pango to render text, rendering non-English characters is easily possible:  .. manim:: MultipleFonts     :save_last_frame:      class MultipleFonts(Scene):         def construct(self):             morning = Text(""வணக்கம்"", font=""sans-serif"")             japanese = Text(                 ""日本へようこそ"", t2c={""日本"": BLUE}             )  # works same as ``Text``.             mess = Text(""Multi-Language"", weight=BOLD)             russ = Text(""Здравствуйте मस नम म "", font=""sans-serif"")             hin = Text(""नमस्ते"", font=""sans-serif"")             arb = Text(                 ""صباح الخير \n تشرفت بمقابلتك"", font=""sans-serif""             )  # don't mix RTL and LTR languages nothing shows up then ;-)             chinese = Text(""臂猿「黛比」帶著孩子"", font=""sans-serif"")             self.add(morning, japanese, mess, russ, hin, arb, chinese)             for i,mobj in enumerate(self.mobjects):                 mobj.shift(DOWN*(i-3))   .. manim:: PangoRender     :quality: low      class PangoRender(Scene):         def construct(self):             morning = Text(""வணக்கம்"", font=""sans-serif"")             self.play(Write(morning))             self.wait(2)  Tests -----  Check that the creation of :class:`~.Text` works::      >>> Text('The horse does not eat cucumber salad.')     Text('The horse does not eat cucumber salad.')"
Text,manim.mobject.text.text_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/text_mobject.py,"Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.  Text objects behave like a :class:`.VGroup`-like iterable of all characters in the given text. In particular, slicing is possible.  Parameters ---------- text     The text that needs to be created as a mobject. font     The font family to be used to render the text. This is either a system font or     one loaded with `register_font()`. Note that font family names may be different     across operating systems. warn_missing_font     If True (default), Manim will issue a warning if the font does not exist in the     (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.  Returns ------- :class:`Text`     The mobject-like :class:`.VGroup`.  Examples ---------  .. manim:: Example1Text     :save_last_frame:      class Example1Text(Scene):         def construct(self):             text = Text('Hello world').scale(3)             self.add(text)  .. manim:: TextColorExample     :save_last_frame:      class TextColorExample(Scene):         def construct(self):             text1 = Text('Hello world', color=BLUE).scale(3)             text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)             self.add(text1, text2)  .. manim:: TextItalicAndBoldExample     :save_last_frame:      class TextItalicAndBoldExample(Scene):         def construct(self):             text1 = Text(""Hello world"", slant=ITALIC)             text2 = Text(""Hello world"", t2s={'world':ITALIC})             text3 = Text(""Hello world"", weight=BOLD)             text4 = Text(""Hello world"", t2w={'world':BOLD})             text5 = Text(""Hello world"", t2c={'o':YELLOW}, disable_ligatures=True)             text6 = Text(                 ""Visit us at docs.manim.community"",                 t2c={""docs.manim.community"": YELLOW},                 disable_ligatures=True,            )             text6.scale(1.3).shift(DOWN)             self.add(text1, text2, text3, text4, text5 , text6)             Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)  .. manim:: TextMoreCustomization         :save_last_frame:          class TextMoreCustomization(Scene):             def construct(self):                 text1 = Text(                     'Google',                     t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',                          '[2:3]': '#fbb003', '[3:4]': '#3174f0',                          '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)                 self.add(text1)  As :class:`Text` uses Pango to render text, rendering non-English characters is easily possible:  .. manim:: MultipleFonts     :save_last_frame:      class MultipleFonts(Scene):         def construct(self):             morning = Text(""வணக்கம்"", font=""sans-serif"")             japanese = Text(                 ""日本へようこそ"", t2c={""日本"": BLUE}             )  # works same as ``Text``.             mess = Text(""Multi-Language"", weight=BOLD)             russ = Text(""Здравствуйте मस नम म "", font=""sans-serif"")             hin = Text(""नमस्ते"", font=""sans-serif"")             arb = Text(                 ""صباح الخير \n تشرفت بمقابلتك"", font=""sans-serif""             )  # don't mix RTL and LTR languages nothing shows up then ;-)             chinese = Text(""臂猿「黛比」帶著孩子"", font=""sans-serif"")             self.add(morning, japanese, mess, russ, hin, arb, chinese)             for i,mobj in enumerate(self.mobjects):                 mobj.shift(DOWN*(i-3))   .. manim:: PangoRender     :quality: low      class PangoRender(Scene):         def construct(self):             morning = Text(""வணக்கம்"", font=""sans-serif"")             self.play(Write(morning))             self.wait(2)  Tests -----  Check that the creation of :class:`~.Text` works::      >>> Text('The horse does not eat cucumber salad.')     Text('The horse does not eat cucumber salad.')"
Text,manim.mobject.text.text_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/text/text_mobject.py,"Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.  Text objects behave like a :class:`.VGroup`-like iterable of all characters in the given text. In particular, slicing is possible.  Parameters ---------- text     The text that needs to be created as a mobject. font     The font family to be used to render the text. This is either a system font or     one loaded with `register_font()`. Note that font family names may be different     across operating systems. warn_missing_font     If True (default), Manim will issue a warning if the font does not exist in the     (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.  Returns ------- :class:`Text`     The mobject-like :class:`.VGroup`.  Examples ---------  .. manim:: Example1Text     :save_last_frame:      class Example1Text(Scene):         def construct(self):             text = Text('Hello world').scale(3)             self.add(text)  .. manim:: TextColorExample     :save_last_frame:      class TextColorExample(Scene):         def construct(self):             text1 = Text('Hello world', color=BLUE).scale(3)             text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)             self.add(text1, text2)  .. manim:: TextItalicAndBoldExample     :save_last_frame:      class TextItalicAndBoldExample(Scene):         def construct(self):             text1 = Text(""Hello world"", slant=ITALIC)             text2 = Text(""Hello world"", t2s={'world':ITALIC})             text3 = Text(""Hello world"", weight=BOLD)             text4 = Text(""Hello world"", t2w={'world':BOLD})             text5 = Text(""Hello world"", t2c={'o':YELLOW}, disable_ligatures=True)             text6 = Text(                 ""Visit us at docs.manim.community"",                 t2c={""docs.manim.community"": YELLOW},                 disable_ligatures=True,            )             text6.scale(1.3).shift(DOWN)             self.add(text1, text2, text3, text4, text5 , text6)             Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)  .. manim:: TextMoreCustomization         :save_last_frame:          class TextMoreCustomization(Scene):             def construct(self):                 text1 = Text(                     'Google',                     t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',                          '[2:3]': '#fbb003', '[3:4]': '#3174f0',                          '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)                 self.add(text1)  As :class:`Text` uses Pango to render text, rendering non-English characters is easily possible:  .. manim:: MultipleFonts     :save_last_frame:      class MultipleFonts(Scene):         def construct(self):             morning = Text(""வணக்கம்"", font=""sans-serif"")             japanese = Text(                 ""日本へようこそ"", t2c={""日本"": BLUE}             )  # works same as ``Text``.             mess = Text(""Multi-Language"", weight=BOLD)             russ = Text(""Здравствуйте मस नम म "", font=""sans-serif"")             hin = Text(""नमस्ते"", font=""sans-serif"")             arb = Text(                 ""صباح الخير \n تشرفت بمقابلتك"", font=""sans-serif""             )  # don't mix RTL and LTR languages nothing shows up then ;-)             chinese = Text(""臂猿「黛比」帶著孩子"", font=""sans-serif"")             self.add(morning, japanese, mess, russ, hin, arb, chinese)             for i,mobj in enumerate(self.mobjects):                 mobj.shift(DOWN*(i-3))   .. manim:: PangoRender     :quality: low      class PangoRender(Scene):         def construct(self):             morning = Text(""வணக்கம்"", font=""sans-serif"")             self.play(Write(morning))             self.wait(2)  Tests -----  Check that the creation of :class:`~.Text` works::      >>> Text('The horse does not eat cucumber salad.')     Text('The horse does not eat cucumber salad.')"
ConvexHull3D,manim.mobject.three_d.polyhedra,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/polyhedra.py,"A convex hull for a set of points  Parameters ---------- points     The points to consider. tolerance     The tolerance used for quickhull. kwargs     Forwarded to the parent constructor.  Examples -------- .. manim:: ConvexHull3DExample     :save_last_frame:     :quality: high      class ConvexHull3DExample(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             points = [                 [ 1.93192757,  0.44134585, -1.52407061],                 [-0.93302521,  1.23206983,  0.64117067],                 [-0.44350918, -0.61043677,  0.21723705],                 [-0.42640268, -1.05260843,  1.61266094],                 [-1.84449637,  0.91238739, -1.85172623],                 [ 1.72068132, -0.11880457,  0.51881751],                 [ 0.41904805,  0.44938012, -1.86440686],                 [ 0.83864666,  1.66653337,  1.88960123],                 [ 0.22240514, -0.80986286,  1.34249326],                 [-1.29585759,  1.01516189,  0.46187522],                 [ 1.7776499,  -1.59550796, -1.70240747],                 [ 0.80065226, -0.12530398,  1.70063977],                 [ 1.28960948, -1.44158255,  1.39938582],                 [-0.93538943,  1.33617705, -0.24852643],                 [-1.54868271,  1.7444399,  -0.46170734]             ]             hull = ConvexHull3D(                 *points,                 faces_config = {""stroke_opacity"": 0},                 graph_config = {                     ""vertex_type"": Dot3D,                     ""edge_config"": {                         ""stroke_color"": BLUE,                         ""stroke_width"": 2,                         ""stroke_opacity"": 0.05,                     }                 }             )             dots = VGroup(*[Dot3D(point) for point in points])             self.add(hull)             self.add(dots)"
Dodecahedron,manim.mobject.three_d.polyhedra,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/polyhedra.py,"A dodecahedron, one of the five platonic solids. It has 12 faces, 30 edges and 20 vertices.  Parameters ---------- edge_length     The length of an edge between any two vertices.  Examples --------  .. manim:: DodecahedronScene     :save_last_frame:      class DodecahedronScene(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             obj = Dodecahedron()             self.add(obj)"
Icosahedron,manim.mobject.three_d.polyhedra,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/polyhedra.py,"An icosahedron, one of the five platonic solids. It has 20 faces, 30 edges and 12 vertices.  Parameters ---------- edge_length     The length of an edge between any two vertices.  Examples --------  .. manim:: IcosahedronScene     :save_last_frame:      class IcosahedronScene(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             obj = Icosahedron()             self.add(obj)"
Octahedron,manim.mobject.three_d.polyhedra,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/polyhedra.py,"An octahedron, one of the five platonic solids. It has 8 faces, 12 edges and 6 vertices.  Parameters ---------- edge_length     The length of an edge between any two vertices.  Examples --------  .. manim:: OctahedronScene     :save_last_frame:      class OctahedronScene(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             obj = Octahedron()             self.add(obj)"
Polyhedron,manim.mobject.three_d.polyhedra,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/polyhedra.py,"An abstract polyhedra class.  In this implementation, polyhedra are defined with a list of vertex coordinates in space, and a list of faces. This implementation mirrors that of a standard polyhedral data format (OFF, object file format).  Parameters ---------- vertex_coords     A list of coordinates of the corresponding vertices in the polyhedron. Each coordinate will correspond to     a vertex. The vertices are indexed with the usual indexing of Python. faces_list     A list of faces. Each face is a sublist containing the indices of the vertices that form the corners of that face. faces_config     Configuration for the polygons representing the faces of the polyhedron. graph_config     Configuration for the graph containing the vertices and edges of the polyhedron.  Examples -------- To understand how to create a custom polyhedra, let's use the example of a rather simple one - a square pyramid.  .. manim:: SquarePyramidScene     :save_last_frame:      class SquarePyramidScene(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             vertex_coords = [                 [1, 1, 0],                 [1, -1, 0],                 [-1, -1, 0],                 [-1, 1, 0],                 [0, 0, 2]             ]             faces_list = [                 [0, 1, 4],                 [1, 2, 4],                 [2, 3, 4],                 [3, 0, 4],                 [0, 1, 2, 3]             ]             pyramid = Polyhedron(vertex_coords, faces_list)             self.add(pyramid)  In defining the polyhedron above, we first defined the coordinates of the vertices. These are the corners of the square base, given as the first four coordinates in the vertex list, and the apex, the last coordinate in the list.  Next, we define the faces of the polyhedron. The triangular surfaces of the pyramid are polygons with two adjacent vertices in the base and the vertex at the apex as corners. We thus define these surfaces in the first four elements of our face list. The last element defines the base of the pyramid.  The graph and faces of polyhedra can also be accessed and modified directly, after instantiation. They are stored in the `graph` and `faces` attributes respectively.  .. manim:: PolyhedronSubMobjects     :save_last_frame:      class PolyhedronSubMobjects(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             octahedron = Octahedron(edge_length = 3)             octahedron.graph[0].set_color(RED)             octahedron.faces[2].set_color(YELLOW)             self.add(octahedron)"
Tetrahedron,manim.mobject.three_d.polyhedra,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/polyhedra.py,"A tetrahedron, one of the five platonic solids. It has 4 faces, 6 edges, and 4 vertices.  Parameters ---------- edge_length     The length of an edge between any two vertices.  Examples --------  .. manim:: TetrahedronScene     :save_last_frame:      class TetrahedronScene(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             obj = Tetrahedron()             self.add(obj)"
Arrow3D,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"An arrow made out of a cylindrical line and a conical tip.  Parameters ---------- start     The start position of the arrow. end     The end position of the arrow. thickness     The thickness of the arrow. height     The height of the conical tip. base_radius     The base radius of the conical tip. color     The color of the arrow. resolution     The resolution of the arrow line.  Examples -------- .. manim:: ExampleArrow3D     :save_last_frame:      class ExampleArrow3D(ThreeDScene):         def construct(self):             axes = ThreeDAxes()             arrow = Arrow3D(                 start=np.array([0, 0, 0]),                 end=np.array([2, 2, 2]),                 resolution=8             )             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             self.add(axes, arrow)"
Cone,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A circular cone. Can be defined using 2 parameters: its height, and its base radius. The polar angle, theta, can be calculated using arctan(base_radius / height) The spherical radius, r, is calculated using the pythagorean theorem.  Parameters ---------- base_radius     The base radius from which the cone tapers. height     The height measured from the plane formed by the base_radius to     the apex of the cone. direction     The direction of the apex. show_base     Whether to show the base plane or not. v_range     The azimuthal angle to start and end at. u_min     The radius at the apex. checkerboard_colors     Show checkerboard grid texture on the cone.  Examples -------- .. manim:: ExampleCone     :save_last_frame:      class ExampleCone(ThreeDScene):         def construct(self):             axes = ThreeDAxes()             cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)             self.set_camera_orientation(phi=5*PI/11, theta=PI/9)             self.add(axes, cone)"
Cube,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A three-dimensional cube.  Parameters ---------- side_length     Length of each side of the :class:`Cube`. fill_opacity     The opacity of the :class:`Cube`, from 0 being fully transparent to 1 being     fully opaque. Defaults to 0.75. fill_color     The color of the :class:`Cube`. stroke_width     The width of the stroke surrounding each face of the :class:`Cube`.  Examples --------  .. manim:: CubeExample     :save_last_frame:      class CubeExample(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)              axes = ThreeDAxes()             cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)             self.add(cube)"
Cylinder,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A cylinder, defined by its height, radius and direction,  Parameters ---------- radius     The radius of the cylinder. height     The height of the cylinder. direction     The direction of the central axis of the cylinder. v_range     The height along the height axis (given by direction) to start and end on. show_ends     Whether to show the end caps or not. resolution     The number of samples taken of the :class:`Cylinder`. A tuple can be used     to define different resolutions for ``u`` and ``v`` respectively.  Examples -------- .. manim:: ExampleCylinder     :save_last_frame:      class ExampleCylinder(ThreeDScene):         def construct(self):             axes = ThreeDAxes()             cylinder = Cylinder(radius=2, height=3)             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             self.add(axes, cylinder)"
Dot3D,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A spherical dot.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. color     The color of the :class:`Dot3D`. resolution     The number of samples taken of the :class:`Dot3D`. A tuple can be     used to define different resolutions for ``u`` and ``v`` respectively.  Examples --------  .. manim:: Dot3DExample     :save_last_frame:      class Dot3DExample(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)              axes = ThreeDAxes()             dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)             dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)             dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)             self.add(axes, dot_1, dot_2,dot_3)"
Dot3D,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A spherical dot.  Parameters ---------- point     The location of the dot. radius     The radius of the dot. color     The color of the :class:`Dot3D`. resolution     The number of samples taken of the :class:`Dot3D`. A tuple can be     used to define different resolutions for ``u`` and ``v`` respectively.  Examples --------  .. manim:: Dot3DExample     :save_last_frame:      class Dot3DExample(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)              axes = ThreeDAxes()             dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)             dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)             dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)             self.add(axes, dot_1, dot_2,dot_3)"
Line3D,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A cylindrical line, for use in ThreeDScene.  Parameters ---------- start     The start point of the line. end     The end point of the line. thickness     The thickness of the line. color     The color of the line. resolution     The resolution of the line.     By default this value is the number of points the line will sampled at.     If you want the line to also come out checkered, use a tuple.     For example, for a line made of 24 points with 4 checker points on each     cylinder, pass the tuple (4, 24).  Examples -------- .. manim:: ExampleLine3D     :save_last_frame:      class ExampleLine3D(ThreeDScene):         def construct(self):             axes = ThreeDAxes()             line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             self.add(axes, line)"
Prism,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A right rectangular prism (or rectangular cuboid). Defined by the length of each side in ``[x, y, z]`` format.  Parameters ---------- dimensions     Dimensions of the :class:`Prism` in ``[x, y, z]`` format.  Examples --------  .. manim:: ExamplePrism     :save_last_frame:      class ExamplePrism(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)             prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)             prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])             self.add(prismSmall, prismLarge)"
Sphere,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A three-dimensional sphere.  Parameters ---------- center     Center of the :class:`Sphere`. radius     The radius of the :class:`Sphere`. resolution     The number of samples taken of the :class:`Sphere`. A tuple can be used     to define different resolutions for ``u`` and ``v`` respectively. u_range     The range of the ``u`` variable: ``(u_min, u_max)``. v_range     The range of the ``v`` variable: ``(v_min, v_max)``.  Examples --------  .. manim:: ExampleSphere     :save_last_frame:      class ExampleSphere(ThreeDScene):         def construct(self):             self.set_camera_orientation(phi=PI / 6, theta=PI / 6)             sphere1 = Sphere(                 center=(3, 0, 0),                 radius=1,                 resolution=(20, 20),                 u_range=[0.001, PI - 0.001],                 v_range=[0, TAU]             )             sphere1.set_color(RED)             self.add(sphere1)             sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))             sphere2.set_color(GREEN)             self.add(sphere2)             sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))             sphere3.set_color(BLUE)             self.add(sphere3)"
Surface,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"Creates a Parametric Surface using a checkerboard pattern.  Parameters ---------- func     The function defining the :class:`Surface`. u_range     The range of the ``u`` variable: ``(u_min, u_max)``. v_range     The range of the ``v`` variable: ``(v_min, v_max)``. resolution     The number of samples taken of the :class:`Surface`. A tuple can be     used to define different resolutions for ``u`` and ``v`` respectively. fill_color     The color of the :class:`Surface`. Ignored if ``checkerboard_colors``     is set. fill_opacity     The opacity of the :class:`Surface`, from 0 being fully transparent     to 1 being fully opaque. Defaults to 1. checkerboard_colors     ng individual faces alternating colors. Overrides ``fill_color``. stroke_color     Color of the stroke surrounding each face of :class:`Surface`. stroke_width     Width of the stroke surrounding each face of :class:`Surface`.     Defaults to 0.5. should_make_jagged     Changes the anchor mode of the Bézier curves from smooth to jagged.     Defaults to ``False``.  Examples -------- .. manim:: ParaSurface     :save_last_frame:      class ParaSurface(ThreeDScene):         def func(self, u, v):             return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])          def construct(self):             axes = ThreeDAxes(x_range=[-4,4], x_length=8)             surface = Surface(                 lambda u, v: axes.c2p(*self.func(u, v)),                 u_range=[-PI, PI],                 v_range=[0, TAU],                 resolution=8,             )             self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)             self.add(axes, surface)"
Surface,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"Creates a Parametric Surface using a checkerboard pattern.  Parameters ---------- func     The function defining the :class:`Surface`. u_range     The range of the ``u`` variable: ``(u_min, u_max)``. v_range     The range of the ``v`` variable: ``(v_min, v_max)``. resolution     The number of samples taken of the :class:`Surface`. A tuple can be     used to define different resolutions for ``u`` and ``v`` respectively. fill_color     The color of the :class:`Surface`. Ignored if ``checkerboard_colors``     is set. fill_opacity     The opacity of the :class:`Surface`, from 0 being fully transparent     to 1 being fully opaque. Defaults to 1. checkerboard_colors     ng individual faces alternating colors. Overrides ``fill_color``. stroke_color     Color of the stroke surrounding each face of :class:`Surface`. stroke_width     Width of the stroke surrounding each face of :class:`Surface`.     Defaults to 0.5. should_make_jagged     Changes the anchor mode of the Bézier curves from smooth to jagged.     Defaults to ``False``.  Examples -------- .. manim:: ParaSurface     :save_last_frame:      class ParaSurface(ThreeDScene):         def func(self, u, v):             return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])          def construct(self):             axes = ThreeDAxes(x_range=[-4,4], x_length=8)             surface = Surface(                 lambda u, v: axes.c2p(*self.func(u, v)),                 u_range=[-PI, PI],                 v_range=[0, TAU],                 resolution=8,             )             self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)             self.add(axes, surface)"
ThreeDVMobject,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
Torus,manim.mobject.three_d.three_dimensions,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/three_d/three_dimensions.py,"A torus.  Parameters ---------- major_radius     Distance from the center of the tube to the center of the torus. minor_radius     Radius of the tube. u_range     The range of the ``u`` variable: ``(u_min, u_max)``. v_range     The range of the ``v`` variable: ``(v_min, v_max)``. resolution     The number of samples taken of the :class:`Torus`. A tuple can be     used to define different resolutions for ``u`` and ``v`` respectively.  Examples -------- .. manim :: ExampleTorus     :save_last_frame:      class ExampleTorus(ThreeDScene):         def construct(self):             axes = ThreeDAxes()             torus = Torus()             self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)             self.add(axes, torus)"
AbstractImageMobject,manim.mobject.types.image_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/image_mobject.py,"Automatically filters out black pixels  Parameters ---------- scale_to_resolution     At this resolution the image is placed pixel by pixel onto the screen, so it     will look the sharpest and best.     This is a custom parameter of ImageMobject so that rendering a scene with     e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering     won't effect the position of the image on the screen."
ImageMobject,manim.mobject.types.image_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/image_mobject.py,"Displays an Image from a numpy array or a file.  Parameters ---------- scale_to_resolution     At this resolution the image is placed pixel by pixel onto the screen, so it     will look the sharpest and best.     This is a custom parameter of ImageMobject so that rendering a scene with     e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering     won't effect the position of the image on the screen.   Example ------- .. manim:: ImageFromArray     :save_last_frame:      class ImageFromArray(Scene):         def construct(self):             image = ImageMobject(np.uint8([[0, 100, 30, 200],                                            [255, 0, 5, 33]]))             image.height = 7             self.add(image)   Changing interpolation style:  .. manim:: ImageInterpolationEx     :save_last_frame:      class ImageInterpolationEx(Scene):         def construct(self):             img = ImageMobject(np.uint8([[63, 0, 0, 0],                                             [0, 127, 0, 0],                                             [0, 0, 191, 0],                                             [0, 0, 0, 255]                                             ]))              img.height = 2             img1 = img.copy()             img2 = img.copy()             img3 = img.copy()             img4 = img.copy()             img5 = img.copy()              img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""nearest""])             img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""lanczos""])             img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""linear""])             img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""cubic""])             img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[""box""])             img1.add(Text(""nearest"").scale(0.5).next_to(img1,UP))             img2.add(Text(""lanczos"").scale(0.5).next_to(img2,UP))             img3.add(Text(""linear"").scale(0.5).next_to(img3,UP))             img4.add(Text(""cubic"").scale(0.5).next_to(img4,UP))             img5.add(Text(""box"").scale(0.5).next_to(img5,UP))              x= Group(img1,img2,img3,img4,img5)             x.arrange()             self.add(x)"
ImageMobjectFromCamera,manim.mobject.types.image_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/image_mobject.py,"Automatically filters out black pixels  Parameters ---------- scale_to_resolution     At this resolution the image is placed pixel by pixel onto the screen, so it     will look the sharpest and best.     This is a custom parameter of ImageMobject so that rendering a scene with     e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering     won't effect the position of the image on the screen."
Mobject1D,manim.mobject.types.point_cloud_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/point_cloud_mobject.py,"A disc made of a cloud of Dots  Examples --------  .. manim:: PMobjectExample     :save_last_frame:      class PMobjectExample(Scene):         def construct(self):              pG = PGroup()  # This is just a collection of PMobject's              # As the scale factor increases, the number of points             # removed increases.             for sf in range(1, 9 + 1):                 p = PointCloudDot(density=20, radius=1).thin_out(sf)                 # PointCloudDot is a type of PMobject                 # and can therefore be added to a PGroup                 pG.add(p)              # This organizes all the shapes in a grid.             pG.arrange_in_grid()              self.add(pG)"
Mobject2D,manim.mobject.types.point_cloud_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/point_cloud_mobject.py,"A disc made of a cloud of Dots  Examples --------  .. manim:: PMobjectExample     :save_last_frame:      class PMobjectExample(Scene):         def construct(self):              pG = PGroup()  # This is just a collection of PMobject's              # As the scale factor increases, the number of points             # removed increases.             for sf in range(1, 9 + 1):                 p = PointCloudDot(density=20, radius=1).thin_out(sf)                 # PointCloudDot is a type of PMobject                 # and can therefore be added to a PGroup                 pG.add(p)              # This organizes all the shapes in a grid.             pG.arrange_in_grid()              self.add(pG)"
PGroup,manim.mobject.types.point_cloud_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/point_cloud_mobject.py,"A group for several point mobjects.  Examples --------  .. manim:: PgroupExample     :save_last_frame:      class PgroupExample(Scene):         def construct(self):              p1 = PointCloudDot(radius=1, density=20, color=BLUE)             p1.move_to(4.5 * LEFT)             p2 = PointCloudDot()             p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)             p3.move_to(4.5 * RIGHT)             pList = PGroup(p1, p2, p3)              self.add(pList)"
PMobject,manim.mobject.types.point_cloud_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/point_cloud_mobject.py,"A disc made of a cloud of Dots  Examples --------  .. manim:: PMobjectExample     :save_last_frame:      class PMobjectExample(Scene):         def construct(self):              pG = PGroup()  # This is just a collection of PMobject's              # As the scale factor increases, the number of points             # removed increases.             for sf in range(1, 9 + 1):                 p = PointCloudDot(density=20, radius=1).thin_out(sf)                 # PointCloudDot is a type of PMobject                 # and can therefore be added to a PGroup                 pG.add(p)              # This organizes all the shapes in a grid.             pG.arrange_in_grid()              self.add(pG)"
PMobject,manim.mobject.types.point_cloud_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/point_cloud_mobject.py,"A disc made of a cloud of Dots  Examples --------  .. manim:: PMobjectExample     :save_last_frame:      class PMobjectExample(Scene):         def construct(self):              pG = PGroup()  # This is just a collection of PMobject's              # As the scale factor increases, the number of points             # removed increases.             for sf in range(1, 9 + 1):                 p = PointCloudDot(density=20, radius=1).thin_out(sf)                 # PointCloudDot is a type of PMobject                 # and can therefore be added to a PGroup                 pG.add(p)              # This organizes all the shapes in a grid.             pG.arrange_in_grid()              self.add(pG)"
Point,manim.mobject.types.point_cloud_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/point_cloud_mobject.py,"A mobject representing a point.  Examples --------  .. manim:: ExamplePoint     :save_last_frame:      class ExamplePoint(Scene):         def construct(self):             colorList = [RED, GREEN, BLUE, YELLOW]             for i in range(200):                 point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))                 self.add(point)             for i in range(200):                 point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))                 self.add(point)             self.add(point)"
PointCloudDot,manim.mobject.types.point_cloud_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/point_cloud_mobject.py,"A disc made of a cloud of dots.  Examples -------- .. manim:: PointCloudDotExample     :save_last_frame:      class PointCloudDotExample(Scene):         def construct(self):             cloud_1 = PointCloudDot(color=RED)             cloud_2 = PointCloudDot(stroke_width=4, radius=1)             cloud_3 = PointCloudDot(density=15)              group = Group(cloud_1, cloud_2, cloud_3).arrange()             self.add(group)  .. manim:: PointCloudDotExample2      class PointCloudDotExample2(Scene):         def construct(self):             plane = ComplexPlane()             cloud = PointCloudDot(color=RED)             self.add(                 plane, cloud             )             self.wait()             self.play(                 cloud.animate.apply_complex_function(lambda z: np.exp(z))             )"
CurvesAsSubmobjects,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"Convert a curve's elements to submobjects.  Examples -------- .. manim:: LineGradientExample     :save_last_frame:      class LineGradientExample(Scene):         def construct(self):             curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)             new_curve = CurvesAsSubmobjects(curve)             new_curve.set_color_by_gradient(BLUE, RED)             self.add(new_curve.shift(UP), curve)"
DashedVMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A :class:`VMobject` composed of dashes instead of lines.  Parameters ----------     vmobject         The object that will get dashed     num_dashes         Number of dashes to add.     dashed_ratio         Ratio of dash to empty space.     dash_offset         Shifts the starting point of dashes along the         path. Value 1 shifts by one full dash length.     equal_lengths         If ``True``, dashes will be (approximately) equally long.         If ``False``, dashes will be split evenly in the curve's         input t variable (legacy behavior).  Examples -------- .. manim:: DashedVMobjectExample     :save_last_frame:      class DashedVMobjectExample(Scene):         def construct(self):             r = 0.5              top_row = VGroup()  # Increasing num_dashes             for dashes in range(1, 12):                 circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)                 top_row.add(circ)              middle_row = VGroup()  # Increasing dashed_ratio             for ratio in np.arange(1 / 11, 1, 1 / 11):                 circ = DashedVMobject(                     Circle(radius=r, color=WHITE), dashed_ratio=ratio                 )                 middle_row.add(circ)              func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)             func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)             func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)             bottom_row = VGroup(func_even,func_stretched)               top_row.arrange(buff=0.3)             middle_row.arrange()             bottom_row.arrange(buff=1)             everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)             self.add(everything)"
DashedVMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A :class:`VMobject` composed of dashes instead of lines.  Parameters ----------     vmobject         The object that will get dashed     num_dashes         Number of dashes to add.     dashed_ratio         Ratio of dash to empty space.     dash_offset         Shifts the starting point of dashes along the         path. Value 1 shifts by one full dash length.     equal_lengths         If ``True``, dashes will be (approximately) equally long.         If ``False``, dashes will be split evenly in the curve's         input t variable (legacy behavior).  Examples -------- .. manim:: DashedVMobjectExample     :save_last_frame:      class DashedVMobjectExample(Scene):         def construct(self):             r = 0.5              top_row = VGroup()  # Increasing num_dashes             for dashes in range(1, 12):                 circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)                 top_row.add(circ)              middle_row = VGroup()  # Increasing dashed_ratio             for ratio in np.arange(1 / 11, 1, 1 / 11):                 circ = DashedVMobject(                     Circle(radius=r, color=WHITE), dashed_ratio=ratio                 )                 middle_row.add(circ)              func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)             func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)             func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)             bottom_row = VGroup(func_even,func_stretched)               top_row.arrange(buff=0.3)             middle_row.arrange()             bottom_row.arrange(buff=1)             everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)             self.add(everything)"
VDict,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A VGroup-like class, also offering submobject access by key, like a python dict  Parameters ---------- mapping_or_iterable         The parameter specifying the key-value mapping of keys and mobjects. show_keys         Whether to also display the key associated with         the mobject. This might be useful when debugging,         especially when there are a lot of mobjects in the         :class:`VDict`. Defaults to False. kwargs         Other arguments to be passed to `Mobject`.  Attributes ---------- show_keys : :class:`bool`         Whether to also display the key associated with         the mobject. This might be useful when debugging,         especially when there are a lot of mobjects in the         :class:`VDict`. When displayed, the key is towards         the left of the mobject.         Defaults to False. submob_dict : :class:`dict`         Is the actual python dictionary that is used to bind         the keys to the mobjects.  Examples --------  .. manim:: ShapesWithVDict      class ShapesWithVDict(Scene):         def construct(self):             square = Square().set_color(RED)             circle = Circle().set_color(YELLOW).next_to(square, UP)              # create dict from list of tuples each having key-mobject pair             pairs = [(""s"", square), (""c"", circle)]             my_dict = VDict(pairs, show_keys=True)              # display it just like a VGroup             self.play(Create(my_dict))             self.wait()              text = Tex(""Some text"").set_color(GREEN).next_to(square, DOWN)              # add a key-value pair by wrapping it in a single-element list of tuple             # after attrs branch is merged, it will be easier like `.add(t=text)`             my_dict.add([(""t"", text)])             self.wait()              rect = Rectangle().next_to(text, DOWN)             # can also do key assignment like a python dict             my_dict[""r""] = rect              # access submobjects like a python dict             my_dict[""t""].set_color(PURPLE)             self.play(my_dict[""t""].animate.scale(3))             self.wait()              # also supports python dict styled reassignment             my_dict[""t""] = Tex(""Some other text"").set_color(BLUE)             self.wait()              # remove submobject by key             my_dict.remove(""t"")             self.wait()              self.play(Uncreate(my_dict[""s""]))             self.wait()              self.play(FadeOut(my_dict[""c""]))             self.wait()              self.play(FadeOut(my_dict[""r""], shift=DOWN))             self.wait()              # you can also make a VDict from an existing dict of mobjects             plain_dict = {                 1: Integer(1).shift(DOWN),                 2: Integer(2).shift(2 * DOWN),                 3: Integer(3).shift(3 * DOWN),             }              vdict_from_plain_dict = VDict(plain_dict)             vdict_from_plain_dict.shift(1.5 * (UP + LEFT))             self.play(Create(vdict_from_plain_dict))              # you can even use zip             vdict_using_zip = VDict(zip([""s"", ""c"", ""r""], [Square(), Circle(), Rectangle()]))             vdict_using_zip.shift(1.5 * RIGHT)             self.play(Create(vdict_using_zip))             self.wait()"
VDict,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A VGroup-like class, also offering submobject access by key, like a python dict  Parameters ---------- mapping_or_iterable         The parameter specifying the key-value mapping of keys and mobjects. show_keys         Whether to also display the key associated with         the mobject. This might be useful when debugging,         especially when there are a lot of mobjects in the         :class:`VDict`. Defaults to False. kwargs         Other arguments to be passed to `Mobject`.  Attributes ---------- show_keys : :class:`bool`         Whether to also display the key associated with         the mobject. This might be useful when debugging,         especially when there are a lot of mobjects in the         :class:`VDict`. When displayed, the key is towards         the left of the mobject.         Defaults to False. submob_dict : :class:`dict`         Is the actual python dictionary that is used to bind         the keys to the mobjects.  Examples --------  .. manim:: ShapesWithVDict      class ShapesWithVDict(Scene):         def construct(self):             square = Square().set_color(RED)             circle = Circle().set_color(YELLOW).next_to(square, UP)              # create dict from list of tuples each having key-mobject pair             pairs = [(""s"", square), (""c"", circle)]             my_dict = VDict(pairs, show_keys=True)              # display it just like a VGroup             self.play(Create(my_dict))             self.wait()              text = Tex(""Some text"").set_color(GREEN).next_to(square, DOWN)              # add a key-value pair by wrapping it in a single-element list of tuple             # after attrs branch is merged, it will be easier like `.add(t=text)`             my_dict.add([(""t"", text)])             self.wait()              rect = Rectangle().next_to(text, DOWN)             # can also do key assignment like a python dict             my_dict[""r""] = rect              # access submobjects like a python dict             my_dict[""t""].set_color(PURPLE)             self.play(my_dict[""t""].animate.scale(3))             self.wait()              # also supports python dict styled reassignment             my_dict[""t""] = Tex(""Some other text"").set_color(BLUE)             self.wait()              # remove submobject by key             my_dict.remove(""t"")             self.wait()              self.play(Uncreate(my_dict[""s""]))             self.wait()              self.play(FadeOut(my_dict[""c""]))             self.wait()              self.play(FadeOut(my_dict[""r""], shift=DOWN))             self.wait()              # you can also make a VDict from an existing dict of mobjects             plain_dict = {                 1: Integer(1).shift(DOWN),                 2: Integer(2).shift(2 * DOWN),                 3: Integer(3).shift(3 * DOWN),             }              vdict_from_plain_dict = VDict(plain_dict)             vdict_from_plain_dict.shift(1.5 * (UP + LEFT))             self.play(Create(vdict_from_plain_dict))              # you can even use zip             vdict_using_zip = VDict(zip([""s"", ""c"", ""r""], [Square(), Circle(), Rectangle()]))             vdict_using_zip.shift(1.5 * RIGHT)             self.play(Create(vdict_using_zip))             self.wait()"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VGroup,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A group of vectorized mobjects.  This can be used to group multiple :class:`~.VMobject` instances together in order to scale, move, ... them together.  Notes ----- When adding the same mobject more than once, repetitions are ignored. Use :meth:`.Mobject.copy` to create a separate copy which can then be added to the group.  Examples --------  To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or `-` and `-=` operators:      >>> from manim import Triangle, Square, VGroup     >>> vg = VGroup()     >>> triangle, square = Triangle(), Square()     >>> vg.add(triangle)     VGroup(Triangle)     >>> vg + square  # a new VGroup is constructed     VGroup(Triangle, Square)     >>> vg  # not modified     VGroup(Triangle)     >>> vg += square     >>> vg  # modifies vg     VGroup(Triangle, Square)     >>> vg.remove(triangle)     VGroup(Square)     >>> vg - square  # a new VGroup is constructed     VGroup()     >>> vg  # not modified     VGroup(Square)     >>> vg -= square     >>> vg  # modifies vg     VGroup()  .. manim:: ArcShapeIris     :save_last_frame:      class ArcShapeIris(Scene):         def construct(self):             colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]             radius = [1 + rad * 0.1 for rad in range(len(colors))]              circles_group = VGroup()              # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]             circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)                                 for rad, col in zip(radius, colors)])             self.add(circles_group)"
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VMobject,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VectorizedPoint,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VectorizedPoint,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
VectorizedPoint,manim.mobject.types.vectorized_mobject,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/types/vectorized_mobject.py,"A vectorized mobject.  Parameters ---------- background_stroke_color     The purpose of background stroke is to have something     that won't overlap fill, e.g.  For text against some     textured background. sheen_factor     When a color c is set, there will be a second color     computed based on interpolating c to WHITE by with     sheen_factor, and the display will gradient to this     secondary color in the direction of sheen_direction. close_new_points     Indicates that it will not be displayed, but     that it should count in parent mobject's path tolerance_for_point_equality     This is within a pixel joint_type     The line joint type used to connect the curve segments     of this vectorized mobject. See :class:`.LineJointType`     for options."
ComplexValueTracker,manim.mobject.value_tracker,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/value_tracker.py,"Tracks a complex-valued parameter.  When the value is set through :attr:`animate`, the value will take a straight path from the source point to the destination point.  Examples -------- .. manim:: ComplexValueTrackerExample      class ComplexValueTrackerExample(Scene):         def construct(self):             tracker = ComplexValueTracker(-2+1j)             dot = Dot().add_updater(                 lambda x: x.move_to(tracker.points)             )              self.add(NumberPlane(), dot)              self.play(tracker.animate.set_value(3+2j))             self.play(tracker.animate.set_value(tracker.get_value() * 1j))             self.play(tracker.animate.set_value(tracker.get_value() - 2j))             self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))"
ValueTracker,manim.mobject.value_tracker,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/value_tracker.py,"A mobject that can be used for tracking (real-valued) parameters. Useful for animating parameter changes.  Not meant to be displayed.  Instead the position encodes some number, often one which another animation or continual_animation uses for its update function, and by treating it as a mobject it can still be animated and manipulated just like anything else.  This value changes continuously when animated using the :attr:`animate` syntax.  Examples -------- .. manim:: ValueTrackerExample      class ValueTrackerExample(Scene):         def construct(self):             number_line = NumberLine()             pointer = Vector(DOWN)             label = MathTex(""x"").add_updater(lambda m: m.next_to(pointer, UP))              tracker = ValueTracker(0)             pointer.add_updater(                 lambda m: m.next_to(                             number_line.n2p(tracker.get_value()),                             UP                         )             )             self.add(number_line, pointer,label)             tracker += 1.5             self.wait(1)             tracker -= 4             self.wait(0.5)             self.play(tracker.animate.set_value(5))             self.wait(0.5)             self.play(tracker.animate.set_value(3))             self.play(tracker.animate.increment_value(-2))             self.wait(0.5)  .. note::      You can also link ValueTrackers to updaters. In this case, you have to make sure that the     ValueTracker is added to the scene by ``add``  .. manim:: ValueTrackerExample      class ValueTrackerExample(Scene):         def construct(self):             tracker = ValueTracker(0)             label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))             self.add(label)             self.add(tracker)             tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))             self.wait(2)"
ValueTracker,manim.mobject.value_tracker,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/value_tracker.py,"A mobject that can be used for tracking (real-valued) parameters. Useful for animating parameter changes.  Not meant to be displayed.  Instead the position encodes some number, often one which another animation or continual_animation uses for its update function, and by treating it as a mobject it can still be animated and manipulated just like anything else.  This value changes continuously when animated using the :attr:`animate` syntax.  Examples -------- .. manim:: ValueTrackerExample      class ValueTrackerExample(Scene):         def construct(self):             number_line = NumberLine()             pointer = Vector(DOWN)             label = MathTex(""x"").add_updater(lambda m: m.next_to(pointer, UP))              tracker = ValueTracker(0)             pointer.add_updater(                 lambda m: m.next_to(                             number_line.n2p(tracker.get_value()),                             UP                         )             )             self.add(number_line, pointer,label)             tracker += 1.5             self.wait(1)             tracker -= 4             self.wait(0.5)             self.play(tracker.animate.set_value(5))             self.wait(0.5)             self.play(tracker.animate.set_value(3))             self.play(tracker.animate.increment_value(-2))             self.wait(0.5)  .. note::      You can also link ValueTrackers to updaters. In this case, you have to make sure that the     ValueTracker is added to the scene by ``add``  .. manim:: ValueTrackerExample      class ValueTrackerExample(Scene):         def construct(self):             tracker = ValueTracker(0)             label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))             self.add(label)             self.add(tracker)             tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))             self.wait(2)"
ArrowVectorField,manim.mobject.vector_field,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/vector_field.py,"A :class:`VectorField` represented by a set of change vectors.  Vector fields are always based on a function defining the :class:`~.Vector` at every position. The values of this functions is displayed as a grid of vectors. By default the color of each vector is determined by it's magnitude. Other color schemes can be used however.  Parameters ---------- func     The function defining the rate of change at every position of the vector field. color     The color of the vector field. If set, position-specific coloring is disabled. color_scheme     A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`. min_color_scheme_value     The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient. max_color_scheme_value     The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient. colors     The colors defining the color gradient of the vector field. x_range     A sequence of x_min, x_max, delta_x y_range     A sequence of y_min, y_max, delta_y z_range     A sequence of z_min, z_max, delta_z three_dimensions     Enables three_dimensions. Default set to False, automatically turns True if     z_range is not None. length_func     The function determining the displayed size of the vectors. The actual size     of the vector is passed, the returned value will be used as display size for the     vector. By default this is used to cap the displayed size of vectors to reduce the clutter. opacity     The opacity of the arrows. vector_config     Additional arguments to be passed to the :class:`~.Vector` constructor kwargs     Additional arguments to be passed to the :class:`~.VGroup` constructor  Examples --------  .. manim:: BasicUsage     :save_last_frame:      class BasicUsage(Scene):         def construct(self):             func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3             self.add(ArrowVectorField(func))  .. manim:: SizingAndSpacing      class SizingAndSpacing(Scene):         def construct(self):             func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT             vf = ArrowVectorField(func, x_range=[-7, 7, 1])             self.add(vf)             self.wait()              length_func = lambda x: x / 3             vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)             self.play(vf.animate.become(vf2))             self.wait()  .. manim:: Coloring     :save_last_frame:      class Coloring(Scene):         def construct(self):             func = lambda pos: pos - LEFT * 5             colors = [RED, YELLOW, BLUE, DARK_GRAY]             min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)             max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)             vf = ArrowVectorField(                 func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors             )             self.add(vf, min_radius, max_radius)"
StreamLines,manim.mobject.vector_field,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/vector_field.py,"StreamLines represent the flow of a :class:`VectorField` using the trace of moving agents.  Vector fields are always based on a function defining the vector at every position. The values of this functions is displayed by moving many agents along the vector field and showing their trace.  Parameters ---------- func     The function defining the rate of change at every position of the vector field. color     The color of the vector field. If set, position-specific coloring is disabled. color_scheme     A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`. min_color_scheme_value     The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient. max_color_scheme_value     The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient. colors     The colors defining the color gradient of the vector field. x_range     A sequence of x_min, x_max, delta_x y_range     A sequence of y_min, y_max, delta_y z_range     A sequence of z_min, z_max, delta_z three_dimensions     Enables three_dimensions. Default set to False, automatically turns True if     z_range is not None. noise_factor     The amount by which the starting position of each agent is altered along each axis. Defaults to :code:`delta_y / 2` if not defined. n_repeats     The number of agents generated at each starting point. dt     The factor by which the distance an agent moves per step is stretched. Lower values result in a better approximation of the trajectories in the vector field. virtual_time     The time the agents get to move in the vector field. Higher values therefore result in longer stream lines. However, this whole time gets simulated upon creation. max_anchors_per_line     The maximum number of anchors per line. Lines with more anchors get reduced in complexity, not in length. padding     The distance agents can move out of the generation area before being terminated. stroke_width     The stroke with of the stream lines. opacity     The opacity of the stream lines.  Examples --------  .. manim:: BasicUsage     :save_last_frame:      class BasicUsage(Scene):         def construct(self):             func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3             self.add(StreamLines(func))  .. manim:: SpawningAndFlowingArea     :save_last_frame:      class SpawningAndFlowingArea(Scene):         def construct(self):             func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5             stream_lines = StreamLines(                 func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1             )              spawning_area = Rectangle(width=6, height=4)             flowing_area = Rectangle(width=8, height=6)             labels = [Tex(""Spawning Area""), Tex(""Flowing Area"").shift(DOWN * 2.5)]             for lbl in labels:                 lbl.add_background_rectangle(opacity=0.6, buff=0.05)              self.add(stream_lines, spawning_area, flowing_area, *labels)"
VectorField,manim.mobject.vector_field,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/mobject/vector_field.py,"A vector field.  Vector fields are based on a function defining a vector at every position. This class does by default not include any visible elements but provides methods to move other :class:`~.Mobject` s along the vector field.  Parameters ---------- func     The function defining the rate of change at every position of the `VectorField`. color     The color of the vector field. If set, position-specific coloring is disabled. color_scheme     A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`. min_color_scheme_value     The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient. max_color_scheme_value     The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient. colors     The colors defining the color gradient of the vector field. kwargs     Additional arguments to be passed to the :class:`~.VGroup` constructor"

Animations
Class Name,Module,File Path,Description
Add,manim.animation.animation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/animation.py,"Add Mobjects to a scene, without animating them in any other way. This is similar to the :meth:`.Scene.add` method, but :class:`Add` is an animation which can be grouped into other animations.  Parameters ---------- mobjects     One :class:`~.Mobject` or more to add to a scene. run_time     The duration of the animation after adding the ``mobjects``. Defaults     to 0, which means this is an instant animation without extra wait time     after adding them. **kwargs     Additional arguments to pass to the parent :class:`Animation` class.  Examples --------  .. manim:: DefaultAddScene      class DefaultAddScene(Scene):         def construct(self):             text_1 = Text(""I was added with Add!"")             text_2 = Text(""Me too!"")             text_3 = Text(""And me!"")             texts = VGroup(text_1, text_2, text_3).arrange(DOWN)             rect = SurroundingRectangle(texts, buff=0.5)              self.play(                 Create(rect, run_time=3.0),                 Succession(                     Wait(1.0),                     # You can Add a Mobject in the middle of an animation...                     Add(text_1),                     Wait(1.0),                     # ...or multiple Mobjects at once!                     Add(text_2, text_3),                 ),             )             self.wait()  .. manim:: AddWithRunTimeScene      class AddWithRunTimeScene(Scene):         def construct(self):             # A 5x5 grid of circles             circles = VGroup(                 *[Circle(radius=0.5) for _ in range(25)]             ).arrange_in_grid(5, 5)              self.play(                 Succession(                     # Add a run_time of 0.2 to wait for 0.2 seconds after                     # adding the circle, instead of using Wait(0.2) after Add!                     *[Add(circle, run_time=0.2) for circle in circles],                     rate_func=smooth,                 )             )             self.wait()"
Wait,manim.animation.animation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/animation.py,"A ""no operation"" animation.  Parameters ---------- run_time     The amount of time that should pass. stop_condition     A function without positional arguments that evaluates to a boolean.     The function is evaluated after every new frame has been rendered.     Playing the animation stops after the return value is truthy, or     after the specified ``run_time`` has passed. frozen_frame     Controls whether or not the wait animation is static, i.e., corresponds     to a frozen frame. If ``False`` is passed, the render loop still     progresses through the animation as usual and (among other things)     continues to call updater functions. If ``None`` (the default value),     the :meth:`.Scene.play` call tries to determine whether the Wait call     can be static or not itself via :meth:`.Scene.should_mobjects_update`. kwargs     Keyword arguments to be passed to the parent class, :class:`.Animation`."
Wait,manim.animation.animation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/animation.py,"A ""no operation"" animation.  Parameters ---------- run_time     The amount of time that should pass. stop_condition     A function without positional arguments that evaluates to a boolean.     The function is evaluated after every new frame has been rendered.     Playing the animation stops after the return value is truthy, or     after the specified ``run_time`` has passed. frozen_frame     Controls whether or not the wait animation is static, i.e., corresponds     to a frozen frame. If ``False`` is passed, the render loop still     progresses through the animation as usual and (among other things)     continues to call updater functions. If ``None`` (the default value),     the :meth:`.Scene.play` call tries to determine whether the Wait call     can be static or not itself via :meth:`.Scene.should_mobjects_update`. kwargs     Keyword arguments to be passed to the parent class, :class:`.Animation`."
AnimationGroup,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a group or series of :class:`~.Animation`.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. group     A group of multiple :class:`~.Mobject`. run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative     runtime (see :mod:`~.rate_functions`) . lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 0.0, meaning that all animations will be played together.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time."
AnimationGroup,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a group or series of :class:`~.Animation`.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. group     A group of multiple :class:`~.Mobject`. run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative     runtime (see :mod:`~.rate_functions`) . lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 0.0, meaning that all animations will be played together.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time."
AnimationGroup,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a group or series of :class:`~.Animation`.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. group     A group of multiple :class:`~.Mobject`. run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative     runtime (see :mod:`~.rate_functions`) . lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 0.0, meaning that all animations will be played together.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time."
AnimationGroup,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a group or series of :class:`~.Animation`.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. group     A group of multiple :class:`~.Mobject`. run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative     runtime (see :mod:`~.rate_functions`) . lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 0.0, meaning that all animations will be played together.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time."
LaggedStart,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Adjusts the timing of a series of :class:`~.Animation` according to ``lag_ratio``.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 0.05, meaning that the next animation will begin when 5% of the current     animation has played.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time.  Examples -------- .. manim:: LaggedStartExample      class LaggedStartExample(Scene):         def construct(self):             title = Text(""lag_ratio = 0.25"").to_edge(UP)              dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)             dot2 = Dot(point=LEFT * 2, radius=0.16)             dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)             line_25 = DashedLine(                 start=LEFT + UP * 2,                 end=LEFT + DOWN * 2,                 color=RED             )             label = Text(""25%"", font_size=24).next_to(line_25, UP)             self.add(title, dot1, dot2, dot3, line_25, label)              self.play(LaggedStart(                 dot1.animate.shift(RIGHT * 4),                 dot2.animate.shift(RIGHT * 4),                 dot3.animate.shift(RIGHT * 4),                 lag_ratio=0.25,                 run_time=4             ))"
LaggedStart,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Adjusts the timing of a series of :class:`~.Animation` according to ``lag_ratio``.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 0.05, meaning that the next animation will begin when 5% of the current     animation has played.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time.  Examples -------- .. manim:: LaggedStartExample      class LaggedStartExample(Scene):         def construct(self):             title = Text(""lag_ratio = 0.25"").to_edge(UP)              dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)             dot2 = Dot(point=LEFT * 2, radius=0.16)             dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)             line_25 = DashedLine(                 start=LEFT + UP * 2,                 end=LEFT + DOWN * 2,                 color=RED             )             label = Text(""25%"", font_size=24).next_to(line_25, UP)             self.add(title, dot1, dot2, dot3, line_25, label)              self.play(LaggedStart(                 dot1.animate.shift(RIGHT * 4),                 dot2.animate.shift(RIGHT * 4),                 dot3.animate.shift(RIGHT * 4),                 lag_ratio=0.25,                 run_time=4             ))"
LaggedStartMap,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a series of :class:`~.Animation` while mapping a function to submobjects.  Parameters ---------- AnimationClass     :class:`~.Animation` to apply to mobject. mobject     :class:`~.Mobject` whose submobjects the animation, and optionally the function,     are to be applied. arg_creator     Function which will be applied to :class:`~.Mobject`. run_time     The duration of the animation in seconds.  Examples -------- .. manim:: LaggedStartMapExample      class LaggedStartMapExample(Scene):         def construct(self):             title = Tex(""LaggedStartMap"").to_edge(UP, buff=LARGE_BUFF)             dots = VGroup(                 *[Dot(radius=0.16) for _ in range(35)]                 ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)             self.add(dots, title)              # Animate yellow ripple effect             for mob in dots, title:                 self.play(LaggedStartMap(                     ApplyMethod, mob,                     lambda m : (m.set_color, YELLOW),                     lag_ratio = 0.1,                     rate_func = there_and_back,                     run_time = 2                 ))"
Succession,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a series of animations in succession.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 1.0, meaning that the next animation will begin when 100% of the current     animation has played.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time.  Examples -------- .. manim:: SuccessionExample      class SuccessionExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)             dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)             dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)             dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)             self.add(dot1, dot2, dot3, dot4)              self.play(Succession(                 dot1.animate.move_to(dot2),                 dot2.animate.move_to(dot3),                 dot3.animate.move_to(dot4),                 dot4.animate.move_to(dot1)             ))"
Succession,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a series of animations in succession.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 1.0, meaning that the next animation will begin when 100% of the current     animation has played.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time.  Examples -------- .. manim:: SuccessionExample      class SuccessionExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)             dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)             dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)             dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)             self.add(dot1, dot2, dot3, dot4)              self.play(Succession(                 dot1.animate.move_to(dot2),                 dot2.animate.move_to(dot3),                 dot3.animate.move_to(dot4),                 dot4.animate.move_to(dot1)             ))"
Succession,manim.animation.composition,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/composition.py,"Plays a series of animations in succession.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 1.0, meaning that the next animation will begin when 100% of the current     animation has played.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time.  Examples -------- .. manim:: SuccessionExample      class SuccessionExample(Scene):         def construct(self):             dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)             dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)             dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)             dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)             self.add(dot1, dot2, dot3, dot4)              self.play(Succession(                 dot1.animate.move_to(dot2),                 dot2.animate.move_to(dot3),                 dot3.animate.move_to(dot4),                 dot4.animate.move_to(dot1)             ))"
AddTextLetterByLetter,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,Show a :class:`~.Text` letter by letter on the scene.  Parameters ---------- time_per_char     Frequency of appearance of the letters.  .. tip::      This is currently only possible for class:`~.Text` and not for class:`~.MathTex`
AddTextWordByWord,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,Show a :class:`~.Text` word by word on the scene. Note: currently broken.
Create,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,Incrementally show a VMobject.  Parameters ---------- mobject     The VMobject to animate.  Raises ------ :class:`TypeError`     If ``mobject`` is not an instance of :class:`~.VMobject`.  Examples -------- .. manim:: CreateScene      class CreateScene(Scene):         def construct(self):             self.play(Create(Square()))  See Also -------- :class:`~.ShowPassingFlash`
Create,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,Incrementally show a VMobject.  Parameters ---------- mobject     The VMobject to animate.  Raises ------ :class:`TypeError`     If ``mobject`` is not an instance of :class:`~.VMobject`.  Examples -------- .. manim:: CreateScene      class CreateScene(Scene):         def construct(self):             self.play(Create(Square()))  See Also -------- :class:`~.ShowPassingFlash`
DrawBorderThenFill,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Draw the border first and then show the fill.  Examples -------- .. manim:: ShowDrawBorderThenFill      class ShowDrawBorderThenFill(Scene):         def construct(self):             self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))"
RemoveTextLetterByLetter,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,Remove a :class:`~.Text` letter by letter from the scene.  Parameters ---------- time_per_char     Frequency of appearance of the letters.  .. tip::      This is currently only possible for class:`~.Text` and not for class:`~.MathTex`
ShowIncreasingSubsets,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Show one submobject at a time, leaving all previous ones displayed on screen.  Examples --------  .. manim:: ShowIncreasingSubsetsScene      class ShowIncreasingSubsetsScene(Scene):         def construct(self):             p = VGroup(Dot(), Square(), Triangle())             self.add(p)             self.play(ShowIncreasingSubsets(p))             self.wait()"
ShowPartial,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Abstract class for Animations that show the VMobject partially.  Raises ------ :class:`TypeError`     If ``mobject`` is not an instance of :class:`~.VMobject`.  See Also -------- :class:`Create`, :class:`~.ShowPassingFlash`"
ShowPartial,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Abstract class for Animations that show the VMobject partially.  Raises ------ :class:`TypeError`     If ``mobject`` is not an instance of :class:`~.VMobject`.  See Also -------- :class:`Create`, :class:`~.ShowPassingFlash`"
ShowSubmobjectsOneByOne,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Show one submobject at a time, removing all previously displayed ones from screen."
SpiralIn,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Create the Mobject with sub-Mobjects flying in on spiral trajectories.  Parameters ---------- shapes     The Mobject on which to be operated.  scale_factor     The factor used for scaling the effect.  fade_in_fraction     Fractional duration of initial fade-in of sub-Mobjects as they fly inward.  Examples -------- .. manim :: SpiralInExample      class SpiralInExample(Scene):         def construct(self):             pi = MathTex(r""\pi"").scale(7)             pi.shift(2.25 * LEFT + 1.5 * UP)             circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)             square = Square(color=BLUE_D, fill_opacity=1).shift(UP)             shapes = VGroup(pi, circle, square)             self.play(SpiralIn(shapes))"
TypeWithCursor,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Similar to :class:`~.AddTextLetterByLetter` , but with an additional cursor mobject at the end.  Parameters ---------- time_per_char     Frequency of appearance of the letters. cursor     :class:`~.Mobject` shown after the last added letter. buff     Controls how far away the cursor is to the right of the last added letter. keep_cursor_y     If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter. leave_cursor_on     Whether to show the cursor after the animation.  .. tip::     This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.   Examples --------  .. manim:: InsertingTextExample     :ref_classes: Blink      class InsertingTextExample(Scene):         def construct(self):             text = Text(""Inserting"", color=PURPLE).scale(1.5).to_edge(LEFT)             cursor = Rectangle(                 color = GREY_A,                 fill_color = GREY_A,                 fill_opacity = 1.0,                 height = 1.1,                 width = 0.5,             ).move_to(text[0]) # Position the cursor              self.play(TypeWithCursor(text, cursor))             self.play(Blink(cursor, blinks=2))"
Uncreate,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,Like :class:`Create` but in reverse.  Examples -------- .. manim:: ShowUncreate      class ShowUncreate(Scene):         def construct(self):             self.play(Uncreate(Square()))  See Also -------- :class:`Create`
Uncreate,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,Like :class:`Create` but in reverse.  Examples -------- .. manim:: ShowUncreate      class ShowUncreate(Scene):         def construct(self):             self.play(Uncreate(Square()))  See Also -------- :class:`Create`
UntypeWithCursor,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Similar to :class:`~.RemoveTextLetterByLetter` , but with an additional cursor mobject at the end.  Parameters ---------- time_per_char     Frequency of appearance of the letters. cursor     :class:`~.Mobject` shown after the last added letter. buff     Controls how far away the cursor is to the right of the last added letter. keep_cursor_y     If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter. leave_cursor_on     Whether to show the cursor after the animation.  .. tip::     This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.   Examples --------  .. manim:: DeletingTextExample     :ref_classes: Blink      class DeletingTextExample(Scene):         def construct(self):             text = Text(""Deleting"", color=PURPLE).scale(1.5).to_edge(LEFT)             cursor = Rectangle(                 color = GREY_A,                 fill_color = GREY_A,                 fill_opacity = 1.0,                 height = 1.1,                 width = 0.5,             ).move_to(text[0]) # Position the cursor              self.play(UntypeWithCursor(text, cursor))             self.play(Blink(cursor, blinks=2))"
Unwrite,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Simulate erasing by hand a :class:`~.Text` or a :class:`~.VMobject`.  Parameters ---------- reverse     Set True to have the animation start erasing from the last submobject first.  Examples --------  .. manim :: UnwriteReverseTrue      class UnwriteReverseTrue(Scene):         def construct(self):             text = Tex(""Alice and Bob"").scale(3)             self.add(text)             self.play(Unwrite(text))  .. manim:: UnwriteReverseFalse      class UnwriteReverseFalse(Scene):         def construct(self):             text = Tex(""Alice and Bob"").scale(3)             self.add(text)             self.play(Unwrite(text, reverse=False))"
Write,manim.animation.creation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/creation.py,"Simulate hand-writing a :class:`~.Text` or hand-drawing a :class:`~.VMobject`.  Examples -------- .. manim:: ShowWrite      class ShowWrite(Scene):         def construct(self):             self.play(Write(Text(""Hello"", font_size=144)))  .. manim:: ShowWriteReversed      class ShowWriteReversed(Scene):         def construct(self):             self.play(Write(Text(""Hello"", font_size=144), reverse=True, remover=False))  Tests -----  Check that creating empty :class:`.Write` animations works::      >>> from manim import Write, Text     >>> Write(Text(''))     Write(Text(''))"
FadeIn,manim.animation.fading,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/fading.py,"Fade in :class:`~.Mobject` s.  Parameters ---------- mobjects     The mobjects to be faded in. shift     The vector by which the mobject shifts while being faded in. target_position     The position from which the mobject starts while being faded in. In case     another mobject is given as target position, its center is used. scale     The factor by which the mobject is scaled initially before being rescaling to     its original size while being faded in.  Examples --------  .. manim :: FadeInExample      class FadeInExample(Scene):         def construct(self):             dot = Dot(UP * 2 + LEFT)             self.add(dot)             tex = Tex(                 ""FadeIn with "", ""shift "", r"" or target\_position"", "" and scale""             ).scale(1)             animations = [                 FadeIn(tex[0]),                 FadeIn(tex[1], shift=DOWN),                 FadeIn(tex[2], target_position=dot),                 FadeIn(tex[3], scale=1.5),             ]             self.play(AnimationGroup(*animations, lag_ratio=0.5))"
FadeIn,manim.animation.fading,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/fading.py,"Fade in :class:`~.Mobject` s.  Parameters ---------- mobjects     The mobjects to be faded in. shift     The vector by which the mobject shifts while being faded in. target_position     The position from which the mobject starts while being faded in. In case     another mobject is given as target position, its center is used. scale     The factor by which the mobject is scaled initially before being rescaling to     its original size while being faded in.  Examples --------  .. manim :: FadeInExample      class FadeInExample(Scene):         def construct(self):             dot = Dot(UP * 2 + LEFT)             self.add(dot)             tex = Tex(                 ""FadeIn with "", ""shift "", r"" or target\_position"", "" and scale""             ).scale(1)             animations = [                 FadeIn(tex[0]),                 FadeIn(tex[1], shift=DOWN),                 FadeIn(tex[2], target_position=dot),                 FadeIn(tex[3], scale=1.5),             ]             self.play(AnimationGroup(*animations, lag_ratio=0.5))"
FadeIn,manim.animation.fading,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/fading.py,"Fade in :class:`~.Mobject` s.  Parameters ---------- mobjects     The mobjects to be faded in. shift     The vector by which the mobject shifts while being faded in. target_position     The position from which the mobject starts while being faded in. In case     another mobject is given as target position, its center is used. scale     The factor by which the mobject is scaled initially before being rescaling to     its original size while being faded in.  Examples --------  .. manim :: FadeInExample      class FadeInExample(Scene):         def construct(self):             dot = Dot(UP * 2 + LEFT)             self.add(dot)             tex = Tex(                 ""FadeIn with "", ""shift "", r"" or target\_position"", "" and scale""             ).scale(1)             animations = [                 FadeIn(tex[0]),                 FadeIn(tex[1], shift=DOWN),                 FadeIn(tex[2], target_position=dot),                 FadeIn(tex[3], scale=1.5),             ]             self.play(AnimationGroup(*animations, lag_ratio=0.5))"
FadeOut,manim.animation.fading,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/fading.py,"Fade out :class:`~.Mobject` s.  Parameters ---------- mobjects     The mobjects to be faded out. shift     The vector by which the mobject shifts while being faded out. target_position     The position to which the mobject moves while being faded out. In case another     mobject is given as target position, its center is used. scale     The factor by which the mobject is scaled while being faded out.  Examples --------  .. manim :: FadeInExample      class FadeInExample(Scene):         def construct(self):             dot = Dot(UP * 2 + LEFT)             self.add(dot)             tex = Tex(                 ""FadeOut with "", ""shift "", r"" or target\_position"", "" and scale""             ).scale(1)             animations = [                 FadeOut(tex[0]),                 FadeOut(tex[1], shift=DOWN),                 FadeOut(tex[2], target_position=dot),                 FadeOut(tex[3], scale=0.5),             ]             self.play(AnimationGroup(*animations, lag_ratio=0.5))"
FadeOut,manim.animation.fading,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/fading.py,"Fade out :class:`~.Mobject` s.  Parameters ---------- mobjects     The mobjects to be faded out. shift     The vector by which the mobject shifts while being faded out. target_position     The position to which the mobject moves while being faded out. In case another     mobject is given as target position, its center is used. scale     The factor by which the mobject is scaled while being faded out.  Examples --------  .. manim :: FadeInExample      class FadeInExample(Scene):         def construct(self):             dot = Dot(UP * 2 + LEFT)             self.add(dot)             tex = Tex(                 ""FadeOut with "", ""shift "", r"" or target\_position"", "" and scale""             ).scale(1)             animations = [                 FadeOut(tex[0]),                 FadeOut(tex[1], shift=DOWN),                 FadeOut(tex[2], target_position=dot),                 FadeOut(tex[3], scale=0.5),             ]             self.play(AnimationGroup(*animations, lag_ratio=0.5))"
FadeOut,manim.animation.fading,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/fading.py,"Fade out :class:`~.Mobject` s.  Parameters ---------- mobjects     The mobjects to be faded out. shift     The vector by which the mobject shifts while being faded out. target_position     The position to which the mobject moves while being faded out. In case another     mobject is given as target position, its center is used. scale     The factor by which the mobject is scaled while being faded out.  Examples --------  .. manim :: FadeInExample      class FadeInExample(Scene):         def construct(self):             dot = Dot(UP * 2 + LEFT)             self.add(dot)             tex = Tex(                 ""FadeOut with "", ""shift "", r"" or target\_position"", "" and scale""             ).scale(1)             animations = [                 FadeOut(tex[0]),                 FadeOut(tex[1], shift=DOWN),                 FadeOut(tex[2], target_position=dot),                 FadeOut(tex[3], scale=0.5),             ]             self.play(AnimationGroup(*animations, lag_ratio=0.5))"
_Fade,manim.animation.fading,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/fading.py,"Fade :class:`~.Mobject` s in or out.  Parameters ---------- mobjects     The mobjects to be faded. shift     The vector by which the mobject shifts while being faded. target_position     The position to/from which the mobject moves while being faded in. In case     another mobject is given as target position, its center is used. scale     The factor by which the mobject is scaled initially before being rescaling to     its original size while being faded in."
GrowArrow,manim.animation.growing,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/growing.py,"Introduce an :class:`~.Arrow` by growing it from its start toward its tip.  Parameters ---------- arrow     The arrow to be introduced. point_color     Initial color of the arrow before growing to its full size. Leave empty to match arrow's color.  Examples --------  .. manim :: GrowArrowExample      class GrowArrowExample(Scene):         def construct(self):             arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]             VGroup(*arrows).set_x(0).arrange(buff=2)             self.play(GrowArrow(arrows[0]))             self.play(GrowArrow(arrows[1], point_color=RED))"
GrowFromCenter,manim.animation.growing,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/growing.py,"Introduce an :class:`~.Mobject` by growing it from its center.  Parameters ---------- mobject     The mobjects to be introduced. point_color     Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.  Examples --------  .. manim :: GrowFromCenterExample      class GrowFromCenterExample(Scene):         def construct(self):             squares = [Square() for _ in range(2)]             VGroup(*squares).set_x(0).arrange(buff=2)             self.play(GrowFromCenter(squares[0]))             self.play(GrowFromCenter(squares[1], point_color=RED))"
GrowFromEdge,manim.animation.growing,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/growing.py,"Introduce an :class:`~.Mobject` by growing it from one of its bounding box edges.  Parameters ---------- mobject     The mobjects to be introduced. edge     The direction to seek bounding box edge of mobject. point_color     Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.  Examples --------  .. manim :: GrowFromEdgeExample      class GrowFromEdgeExample(Scene):         def construct(self):             squares = [Square() for _ in range(4)]             VGroup(*squares).set_x(0).arrange(buff=1)             self.play(GrowFromEdge(squares[0], DOWN))             self.play(GrowFromEdge(squares[1], RIGHT))             self.play(GrowFromEdge(squares[2], UR))             self.play(GrowFromEdge(squares[3], UP, point_color=RED))"
GrowFromPoint,manim.animation.growing,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/growing.py,"Introduce an :class:`~.Mobject` by growing it from a point.  Parameters ---------- mobject     The mobjects to be introduced. point     The point from which the mobject grows. point_color     Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.  Examples --------  .. manim :: GrowFromPointExample      class GrowFromPointExample(Scene):         def construct(self):             dot = Dot(3 * UR, color=GREEN)             squares = [Square() for _ in range(4)]             VGroup(*squares).set_x(0).arrange(buff=1)             self.add(dot)             self.play(GrowFromPoint(squares[0], ORIGIN))             self.play(GrowFromPoint(squares[1], [-2, 2, 0]))             self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))             self.play(GrowFromPoint(squares[3], dot, dot.get_color()))"
SpinInFromNothing,manim.animation.growing,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/growing.py,"Introduce an :class:`~.Mobject` spinning and growing it from its center.  Parameters ---------- mobject     The mobjects to be introduced. angle     The amount of spinning before mobject reaches its full size. E.g. 2*PI means     that the object will do one full spin before being fully introduced. point_color     Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.  Examples --------  .. manim :: SpinInFromNothingExample      class SpinInFromNothingExample(Scene):         def construct(self):             squares = [Square() for _ in range(3)]             VGroup(*squares).set_x(0).arrange(buff=2)             self.play(SpinInFromNothing(squares[0]))             self.play(SpinInFromNothing(squares[1], angle=2 * PI))             self.play(SpinInFromNothing(squares[2], point_color=RED))"
ApplyWave,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Send a wave through the Mobject distorting it temporarily.  Parameters ---------- mobject     The mobject to be distorted. direction     The direction in which the wave nudges points of the shape amplitude     The distance points of the shape get shifted wave_func     The function defining the shape of one wave flank. time_width     The length of the wave relative to the width of the mobject. ripples     The number of ripples of the wave run_time     The duration of the animation.  Examples --------  .. manim:: ApplyingWaves      class ApplyingWaves(Scene):         def construct(self):             tex = Tex(""WaveWaveWaveWaveWave"").scale(2)             self.play(ApplyWave(tex))             self.play(ApplyWave(                 tex,                 direction=RIGHT,                 time_width=0.5,                 amplitude=0.3             ))             self.play(ApplyWave(                 tex,                 rate_func=linear,                 ripples=4             ))"
Blink,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Blink the mobject.  Parameters ---------- mobject     The mobject to be blinked. time_on     The duration that the mobject is shown for one blink. time_off     The duration that the mobject is hidden for one blink. blinks     The number of blinks hide_at_end     Whether to hide the mobject at the end of the animation. kwargs     Additional arguments to be passed to the :class:`~.Succession` constructor.  Examples --------  .. manim:: BlinkingExample      class BlinkingExample(Scene):         def construct(self):             text = Text(""Blinking"").scale(1.5)             self.add(text)             self.play(Blink(text, blinks=3))"
Circumscribe,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Draw a temporary line surrounding the mobject.  Parameters ---------- mobject     The mobject to be circumscribed. shape     The shape with which to surround the given mobject. Should be either     :class:`~.Rectangle` or :class:`~.Circle` fade_in     Whether to make the surrounding shape to fade in. It will be drawn otherwise. fade_out     Whether to make the surrounding shape to fade out. It will be undrawn otherwise. time_width     The time_width of the drawing and undrawing. Gets ignored if either `fade_in` or `fade_out` is `True`. buff     The distance between the surrounding shape and the given mobject. color     The color of the surrounding shape. run_time     The duration of the entire animation. kwargs     Additional arguments to be passed to the :class:`~.Succession` constructor  Examples --------  .. manim:: UsingCircumscribe      class UsingCircumscribe(Scene):         def construct(self):             lbl = Tex(r""Circum-\\scribe"").scale(2)             self.add(lbl)             self.play(Circumscribe(lbl))             self.play(Circumscribe(lbl, Circle))             self.play(Circumscribe(lbl, fade_out=True))             self.play(Circumscribe(lbl, time_width=2))             self.play(Circumscribe(lbl, Circle, True))"
Flash,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Send out lines in all directions.  Parameters ---------- point     The center of the flash lines. If it is a :class:`.~Mobject` its center will be used. line_length     The length of the flash lines. num_lines     The number of flash lines. flash_radius     The distance from `point` at which the flash lines start. line_stroke_width     The stroke width of the flash lines. color     The color of the flash lines. time_width     The time width used for the flash lines. See :class:`.~ShowPassingFlash` for more details. run_time     The duration of the animation. kwargs     Additional arguments to be passed to the :class:`~.Succession` constructor  Examples -------- .. manim:: UsingFlash      class UsingFlash(Scene):         def construct(self):             dot = Dot(color=YELLOW).shift(DOWN)             self.add(Tex(""Flash the dot below:""), dot)             self.play(Flash(dot))             self.wait()  .. manim:: FlashOnCircle      class FlashOnCircle(Scene):         def construct(self):             radius = 2             circle = Circle(radius)             self.add(circle)             self.play(Flash(                 circle, line_length=1,                 num_lines=30, color=RED,                 flash_radius=radius+SMALL_BUFF,                 time_width=0.3, run_time=2,                 rate_func = rush_from             ))"
FocusOn,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Shrink a spotlight to a position.  Parameters ---------- focus_point     The point at which to shrink the spotlight. If it is a :class:`.~Mobject` its center will be used. opacity     The opacity of the spotlight. color     The color of the spotlight. run_time     The duration of the animation.  Examples -------- .. manim:: UsingFocusOn      class UsingFocusOn(Scene):         def construct(self):             dot = Dot(color=YELLOW).shift(DOWN)             self.add(Tex(""Focusing on the dot below:""), dot)             self.play(FocusOn(dot))             self.wait()"
Indicate,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Indicate a Mobject by temporarily resizing and recoloring it.  Parameters ---------- mobject     The mobject to indicate. scale_factor     The factor by which the mobject will be temporally scaled color     The color the mobject temporally takes. rate_func     The function defining the animation progress at every point in time. kwargs     Additional arguments to be passed to the :class:`~.Succession` constructor  Examples -------- .. manim:: UsingIndicate      class UsingIndicate(Scene):         def construct(self):             tex = Tex(""Indicate"").scale(3)             self.play(Indicate(tex))             self.wait()"
ShowPassingFlash,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Show only a sliver of the VMobject each frame.  Parameters ---------- mobject     The mobject whose stroke is animated. time_width     The length of the sliver relative to the length of the stroke.  Examples -------- .. manim:: TimeWidthValues      class TimeWidthValues(Scene):         def construct(self):             p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)             lbl = VMobject()             self.add(p, lbl)             p = p.copy().set_color(BLUE)             for time_width in [0.2, 0.5, 1, 2]:                 lbl.become(Tex(r""\texttt{time\_width={{%.1f}}}""%time_width))                 self.play(ShowPassingFlash(                     p.copy().set_color(BLUE),                     run_time=2,                     time_width=time_width                 ))  See Also -------- :class:`~.Create`"
ShowPassingFlashWithThinningStrokeWidth,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Plays a group or series of :class:`~.Animation`.  Parameters ---------- animations     Sequence of :class:`~.Animation` objects to be played. group     A group of multiple :class:`~.Mobject`. run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative     runtime (see :mod:`~.rate_functions`) . lag_ratio     Defines the delay after which the animation is applied to submobjects. A lag_ratio of     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.     Defaults to 0.0, meaning that all animations will be played together.      This does not influence the total runtime of the animation. Instead the runtime     of individual animations is adjusted so that the complete animation has the defined     run time."
Wiggle,manim.animation.indication,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/indication.py,"Wiggle a Mobject.  Parameters ---------- mobject     The mobject to wiggle. scale_value     The factor by which the mobject will be temporarily scaled. rotation_angle     The wiggle angle. n_wiggles     The number of wiggles. scale_about_point     The point about which the mobject gets scaled. rotate_about_point     The point around which the mobject gets rotated. run_time     The duration of the animation  Examples --------  .. manim:: ApplyingWaves      class ApplyingWaves(Scene):         def construct(self):             tex = Tex(""Wiggle"").scale(3)             self.play(Wiggle(tex))             self.wait()"
ComplexHomotopy,manim.animation.movement,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/movement.py,"A Homotopy.  This is an animation transforming the points of a mobject according to the specified transformation function. With the parameter :math:`t` moving from 0 to 1 throughout the animation and :math:`(x, y, z)` describing the coordinates of the point of a mobject, the function passed to the ``homotopy`` keyword argument should transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`, the coordinates the original point is transformed to at time :math:`t`.  Parameters ---------- homotopy     A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`. mobject     The mobject transformed under the given homotopy. run_time     The run time of the animation. apply_function_kwargs     Keyword arguments propagated to :meth:`.Mobject.apply_function`. kwargs     Further keyword arguments passed to the parent class.  Examples --------  .. manim:: HomotopyExample      class HomotopyExample(Scene):         def construct(self):             square = Square()              def homotopy(x, y, z, t):                 if t <= 0.25:                     progress = t / 0.25                     return (x, y + progress * 0.2 * np.sin(x), z)                 else:                     wave_progress = (t - 0.25) / 0.75                     return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)              self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))"
Homotopy,manim.animation.movement,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/movement.py,"A Homotopy.  This is an animation transforming the points of a mobject according to the specified transformation function. With the parameter :math:`t` moving from 0 to 1 throughout the animation and :math:`(x, y, z)` describing the coordinates of the point of a mobject, the function passed to the ``homotopy`` keyword argument should transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`, the coordinates the original point is transformed to at time :math:`t`.  Parameters ---------- homotopy     A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`. mobject     The mobject transformed under the given homotopy. run_time     The run time of the animation. apply_function_kwargs     Keyword arguments propagated to :meth:`.Mobject.apply_function`. kwargs     Further keyword arguments passed to the parent class.  Examples --------  .. manim:: HomotopyExample      class HomotopyExample(Scene):         def construct(self):             square = Square()              def homotopy(x, y, z, t):                 if t <= 0.25:                     progress = t / 0.25                     return (x, y + progress * 0.2 * np.sin(x), z)                 else:                     wave_progress = (t - 0.25) / 0.75                     return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)              self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))"
Homotopy,manim.animation.movement,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/movement.py,"A Homotopy.  This is an animation transforming the points of a mobject according to the specified transformation function. With the parameter :math:`t` moving from 0 to 1 throughout the animation and :math:`(x, y, z)` describing the coordinates of the point of a mobject, the function passed to the ``homotopy`` keyword argument should transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`, the coordinates the original point is transformed to at time :math:`t`.  Parameters ---------- homotopy     A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`. mobject     The mobject transformed under the given homotopy. run_time     The run time of the animation. apply_function_kwargs     Keyword arguments propagated to :meth:`.Mobject.apply_function`. kwargs     Further keyword arguments passed to the parent class.  Examples --------  .. manim:: HomotopyExample      class HomotopyExample(Scene):         def construct(self):             square = Square()              def homotopy(x, y, z, t):                 if t <= 0.25:                     progress = t / 0.25                     return (x, y + progress * 0.2 * np.sin(x), z)                 else:                     wave_progress = (t - 0.25) / 0.75                     return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)              self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))"
MoveAlongPath,manim.animation.movement,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/movement.py,"Make one mobject move along the path of another mobject.  .. manim:: MoveAlongPathExample      class MoveAlongPathExample(Scene):         def construct(self):             d1 = Dot().set_color(ORANGE)             l1 = Line(LEFT, RIGHT)             l2 = VMobject()             self.add(d1, l1, l2)             l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))             self.play(MoveAlongPath(d1, l1), rate_func=linear)"
PhaseFlow,manim.animation.movement,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/movement.py,"An animation.  Animations have a fixed time span.  Parameters ---------- mobject     The mobject to be animated. This is not required for all types of animations. lag_ratio     Defines the delay after which the animation is applied to submobjects. This lag     is relative to the duration of the animation.      This does not influence the total     runtime of the animation. Instead the runtime of individual animations is     adjusted so that the complete animation has the defined run time.  run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .      For example ``rate_func(0.5)`` is the proportion of the animation that is done     after half of the animations run time.   reverse_rate_function     Reverses the rate function of the animation. Setting ``reverse_rate_function``     does not have any effect on ``remover`` or ``introducer``. These need to be     set explicitly if an introducer-animation should be turned into a remover one     and vice versa. name     The name of the animation. This gets displayed while rendering the animation.     Defaults to <class-name>(<Mobject-name>). remover     Whether the given mobject should be removed from the scene after this animation. suspend_mobject_updating     Whether updaters of the mobject should be suspended during the animation.   .. NOTE::      In the current implementation of this class, the specified rate function is applied     within :meth:`.Animation.interpolate_mobject` call as part of the call to     :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`     that are implemented by overriding :meth:`interpolate_mobject`, the rate function     has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead     of just ``alpha``).   Examples --------  .. manim:: LagRatios      class LagRatios(Scene):         def construct(self):             ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios              # Create dot groups             group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()             groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)             self.add(groups)              # Label groups             self.add(Text(""lag_ratio = "", font_size=36).next_to(groups, UP, buff=1.5))             for group, ratio in zip(groups, ratios):                 self.add(Text(str(ratio), font_size=36).next_to(group, UP))              #Animate groups with different lag_ratios             self.play(AnimationGroup(*[                 group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)                 for group, ratio in zip(groups, ratios)             ]))              # lag_ratio also works recursively on nested submobjects:             self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
SmoothedVectorizedHomotopy,manim.animation.movement,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/movement.py,"A Homotopy.  This is an animation transforming the points of a mobject according to the specified transformation function. With the parameter :math:`t` moving from 0 to 1 throughout the animation and :math:`(x, y, z)` describing the coordinates of the point of a mobject, the function passed to the ``homotopy`` keyword argument should transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`, the coordinates the original point is transformed to at time :math:`t`.  Parameters ---------- homotopy     A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`. mobject     The mobject transformed under the given homotopy. run_time     The run time of the animation. apply_function_kwargs     Keyword arguments propagated to :meth:`.Mobject.apply_function`. kwargs     Further keyword arguments passed to the parent class.  Examples --------  .. manim:: HomotopyExample      class HomotopyExample(Scene):         def construct(self):             square = Square()              def homotopy(x, y, z, t):                 if t <= 0.25:                     progress = t / 0.25                     return (x, y + progress * 0.2 * np.sin(x), z)                 else:                     wave_progress = (t - 0.25) / 0.75                     return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)              self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))"
ChangeDecimalToValue,manim.animation.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/numbers.py,"An animation.  Animations have a fixed time span.  Parameters ---------- mobject     The mobject to be animated. This is not required for all types of animations. lag_ratio     Defines the delay after which the animation is applied to submobjects. This lag     is relative to the duration of the animation.      This does not influence the total     runtime of the animation. Instead the runtime of individual animations is     adjusted so that the complete animation has the defined run time.  run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .      For example ``rate_func(0.5)`` is the proportion of the animation that is done     after half of the animations run time.   reverse_rate_function     Reverses the rate function of the animation. Setting ``reverse_rate_function``     does not have any effect on ``remover`` or ``introducer``. These need to be     set explicitly if an introducer-animation should be turned into a remover one     and vice versa. name     The name of the animation. This gets displayed while rendering the animation.     Defaults to <class-name>(<Mobject-name>). remover     Whether the given mobject should be removed from the scene after this animation. suspend_mobject_updating     Whether updaters of the mobject should be suspended during the animation.   .. NOTE::      In the current implementation of this class, the specified rate function is applied     within :meth:`.Animation.interpolate_mobject` call as part of the call to     :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`     that are implemented by overriding :meth:`interpolate_mobject`, the rate function     has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead     of just ``alpha``).   Examples --------  .. manim:: LagRatios      class LagRatios(Scene):         def construct(self):             ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios              # Create dot groups             group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()             groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)             self.add(groups)              # Label groups             self.add(Text(""lag_ratio = "", font_size=36).next_to(groups, UP, buff=1.5))             for group, ratio in zip(groups, ratios):                 self.add(Text(str(ratio), font_size=36).next_to(group, UP))              #Animate groups with different lag_ratios             self.play(AnimationGroup(*[                 group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)                 for group, ratio in zip(groups, ratios)             ]))              # lag_ratio also works recursively on nested submobjects:             self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
ChangingDecimal,manim.animation.numbers,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/numbers.py,"An animation.  Animations have a fixed time span.  Parameters ---------- mobject     The mobject to be animated. This is not required for all types of animations. lag_ratio     Defines the delay after which the animation is applied to submobjects. This lag     is relative to the duration of the animation.      This does not influence the total     runtime of the animation. Instead the runtime of individual animations is     adjusted so that the complete animation has the defined run time.  run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .      For example ``rate_func(0.5)`` is the proportion of the animation that is done     after half of the animations run time.   reverse_rate_function     Reverses the rate function of the animation. Setting ``reverse_rate_function``     does not have any effect on ``remover`` or ``introducer``. These need to be     set explicitly if an introducer-animation should be turned into a remover one     and vice versa. name     The name of the animation. This gets displayed while rendering the animation.     Defaults to <class-name>(<Mobject-name>). remover     Whether the given mobject should be removed from the scene after this animation. suspend_mobject_updating     Whether updaters of the mobject should be suspended during the animation.   .. NOTE::      In the current implementation of this class, the specified rate function is applied     within :meth:`.Animation.interpolate_mobject` call as part of the call to     :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`     that are implemented by overriding :meth:`interpolate_mobject`, the rate function     has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead     of just ``alpha``).   Examples --------  .. manim:: LagRatios      class LagRatios(Scene):         def construct(self):             ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios              # Create dot groups             group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()             groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)             self.add(groups)              # Label groups             self.add(Text(""lag_ratio = "", font_size=36).next_to(groups, UP, buff=1.5))             for group, ratio in zip(groups, ratios):                 self.add(Text(str(ratio), font_size=36).next_to(group, UP))              #Animate groups with different lag_ratios             self.play(AnimationGroup(*[                 group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)                 for group, ratio in zip(groups, ratios)             ]))              # lag_ratio also works recursively on nested submobjects:             self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
Rotate,manim.animation.rotation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/rotation.py,"Animation that rotates a Mobject.  Parameters ---------- mobject     The mobject to be rotated. angle     The rotation angle. axis     The rotation axis as a numpy vector. about_point     The rotation center. about_edge     If ``about_point`` is ``None``, this argument specifies     the direction of the bounding box point to be taken as     the rotation center.  Examples -------- .. manim:: UsingRotate      class UsingRotate(Scene):         def construct(self):             self.play(                 Rotate(                     Square(side_length=0.5).shift(UP * 2),                     angle=2*PI,                     about_point=ORIGIN,                     rate_func=linear,                 ),                 Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),                 )"
Rotating,manim.animation.rotation,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/rotation.py,"An animation.  Animations have a fixed time span.  Parameters ---------- mobject     The mobject to be animated. This is not required for all types of animations. lag_ratio     Defines the delay after which the animation is applied to submobjects. This lag     is relative to the duration of the animation.      This does not influence the total     runtime of the animation. Instead the runtime of individual animations is     adjusted so that the complete animation has the defined run time.  run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .      For example ``rate_func(0.5)`` is the proportion of the animation that is done     after half of the animations run time.   reverse_rate_function     Reverses the rate function of the animation. Setting ``reverse_rate_function``     does not have any effect on ``remover`` or ``introducer``. These need to be     set explicitly if an introducer-animation should be turned into a remover one     and vice versa. name     The name of the animation. This gets displayed while rendering the animation.     Defaults to <class-name>(<Mobject-name>). remover     Whether the given mobject should be removed from the scene after this animation. suspend_mobject_updating     Whether updaters of the mobject should be suspended during the animation.   .. NOTE::      In the current implementation of this class, the specified rate function is applied     within :meth:`.Animation.interpolate_mobject` call as part of the call to     :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`     that are implemented by overriding :meth:`interpolate_mobject`, the rate function     has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead     of just ``alpha``).   Examples --------  .. manim:: LagRatios      class LagRatios(Scene):         def construct(self):             ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios              # Create dot groups             group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()             groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)             self.add(groups)              # Label groups             self.add(Text(""lag_ratio = "", font_size=36).next_to(groups, UP, buff=1.5))             for group, ratio in zip(groups, ratios):                 self.add(Text(str(ratio), font_size=36).next_to(group, UP))              #Animate groups with different lag_ratios             self.play(AnimationGroup(*[                 group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)                 for group, ratio in zip(groups, ratios)             ]))              # lag_ratio also works recursively on nested submobjects:             self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
Broadcast,manim.animation.specialized,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/specialized.py,"Broadcast a mobject starting from an ``initial_width``, up to the actual size of the mobject.  Parameters ---------- mobject     The mobject to be broadcast. focal_point     The center of the broadcast, by default ORIGIN. n_mobs     The number of mobjects that emerge from the focal point, by default 5. initial_opacity     The starting stroke opacity of the mobjects emitted from the broadcast, by default 1. final_opacity     The final stroke opacity of the mobjects emitted from the broadcast, by default 0. initial_width     The initial width of the mobjects, by default 0.0. remover     Whether the mobjects should be removed from the scene after the animation, by default True. lag_ratio     The time between each iteration of the mobject, by default 0.2. run_time     The total duration of the animation, by default 3. kwargs     Additional arguments to be passed to :class:`~.LaggedStart`.  Examples ---------  .. manim:: BroadcastExample      class BroadcastExample(Scene):         def construct(self):             mob = Circle(radius=4, color=TEAL_A)             self.play(Broadcast(mob))"
ChangeSpeed,manim.animation.speedmodifier,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/speedmodifier.py,"Modifies the speed of passed animation. :class:`AnimationGroup` with different ``lag_ratio`` can also be used which combines multiple animations into one. The ``run_time`` of the passed animation is changed to modify the speed.  Parameters ---------- anim     Animation of which the speed is to be modified. speedinfo     Contains nodes (percentage of ``run_time``) and its corresponding speed factor. rate_func     Overrides ``rate_func`` of passed animation, applied before changing speed.  Examples --------  .. manim:: SpeedModifierExample      class SpeedModifierExample(Scene):         def construct(self):             a = Dot().shift(LEFT * 4)             b = Dot().shift(RIGHT * 4)             self.add(a, b)             self.play(                 ChangeSpeed(                     AnimationGroup(                         a.animate(run_time=1).shift(RIGHT * 8),                         b.animate(run_time=1).shift(LEFT * 8),                     ),                     speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},                     rate_func=linear,                 )             )  .. manim:: SpeedModifierUpdaterExample      class SpeedModifierUpdaterExample(Scene):         def construct(self):             a = Dot().shift(LEFT * 4)             self.add(a)              ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))             self.play(                 ChangeSpeed(                     Wait(2),                     speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},                     affects_speed_updaters=True,                 )             )  .. manim:: SpeedModifierUpdaterExample2      class SpeedModifierUpdaterExample2(Scene):         def construct(self):             a = Dot().shift(LEFT * 4)             self.add(a)              ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))             self.wait()             self.play(                 ChangeSpeed(                     Wait(),                     speedinfo={1: 0},                     affects_speed_updaters=True,                 )             )"
ApplyComplexFunction,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Animates a mobject by applying a method.  Note that only the method needs to be passed to this animation, it is not required to pass the corresponding mobject. Furthermore, this animation class only works if the method returns the modified mobject.  Parameters ---------- method     The method that will be applied in the animation. args     Any positional arguments to be passed when applying the method. kwargs     Any keyword arguments passed to :class:`~.Transform`."
ApplyFunction,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
ApplyMatrix,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Applies a matrix transform to an mobject.  Parameters ---------- matrix     The transformation matrix. mobject     The :class:`~.Mobject`. about_point     The origin point for the transform. Defaults to ``ORIGIN``. kwargs     Further keyword arguments that are passed to :class:`ApplyPointwiseFunction`.  Examples --------  .. manim:: ApplyMatrixExample      class ApplyMatrixExample(Scene):         def construct(self):             matrix = [[1, 1], [0, 2/3]]             self.play(ApplyMatrix(matrix, Text(""Hello World!"")), ApplyMatrix(matrix, NumberPlane()))"
ApplyMethod,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Animates a mobject by applying a method.  Note that only the method needs to be passed to this animation, it is not required to pass the corresponding mobject. Furthermore, this animation class only works if the method returns the modified mobject.  Parameters ---------- method     The method that will be applied in the animation. args     Any positional arguments to be passed when applying the method. kwargs     Any keyword arguments passed to :class:`~.Transform`."
ApplyPointwiseFunction,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Animation that applies a pointwise function to a mobject.  Examples --------  .. manim:: WarpSquare     :quality: low      class WarpSquare(Scene):         def construct(self):             square = Square()             self.play(                 ApplyPointwiseFunction(                     lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square                 )             )             self.wait()"
ApplyPointwiseFunctionToCenter,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Animation that applies a pointwise function to a mobject.  Examples --------  .. manim:: WarpSquare     :quality: low      class WarpSquare(Scene):         def construct(self):             square = Square()             self.play(                 ApplyPointwiseFunction(                     lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square                 )             )             self.wait()"
ClockwiseTransform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Transforms the points of a mobject along a clockwise oriented arc.  See also -------- :class:`.Transform`, :class:`.CounterclockwiseTransform`  Examples --------  .. manim:: ClockwiseExample      class ClockwiseExample(Scene):         def construct(self):             dl, dr = Dot(), Dot()             sl, sr = Square(), Square()              VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)             VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)              self.add(dl, dr)             self.wait()             self.play(                 ClockwiseTransform(dl, sl),                 Transform(dr, sr)             )             self.wait()"
CounterclockwiseTransform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Transforms the points of a mobject along a counterclockwise oriented arc.  See also -------- :class:`.Transform`, :class:`.ClockwiseTransform`  Examples --------  .. manim:: CounterclockwiseTransform_vs_Transform      class CounterclockwiseTransform_vs_Transform(Scene):         def construct(self):             # set up the numbers             c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))             text_1 = Text(""CounterclockwiseTransform"", color=RED)             c_transform.add(text_1)              transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))             text_2 = Text(""Transform"", color=BLUE)             transform.add(text_2)              ints = VGroup(c_transform, transform)             texts = VGroup(text_1, text_2).scale(0.75)             c_transform.arrange(direction=UP, buff=1)             transform.arrange(direction=UP, buff=1)              ints.arrange(buff=2)             self.add(ints, texts)              # The mobs move in clockwise direction for ClockwiseTransform()             self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))              # The mobs move straight up for Transform()             self.play(Transform(transform[0], transform[1]))"
CyclicReplace,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"An animation moving mobjects cyclically.  In particular, this means: the first mobject takes the place of the second mobject, the second one takes the place of the third mobject, and so on. The last mobject takes the place of the first one.  Parameters ---------- mobjects     List of mobjects to be transformed. path_arc     The angle of the arc (in radians) that the mobjects will follow to reach     their target. kwargs     Further keyword arguments that are passed to :class:`.Transform`.  Examples -------- .. manim :: CyclicReplaceExample      class CyclicReplaceExample(Scene):         def construct(self):             group = VGroup(Square(), Circle(), Triangle(), Star())             group.arrange(RIGHT)             self.add(group)              for _ in range(4):                 self.play(CyclicReplace(*group))"
FadeToColor,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Animation that changes color of a mobject.  Examples --------  .. manim:: FadeToColorExample      class FadeToColorExample(Scene):         def construct(self):             self.play(FadeToColor(Text(""Hello World!""), color=RED))"
FadeTransform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Fades one mobject into another.  Parameters ---------- mobject     The starting :class:`~.Mobject`. target_mobject     The target :class:`~.Mobject`. stretch     Controls whether the target :class:`~.Mobject` is stretched during     the animation. Default: ``True``. dim_to_match     If the target mobject is not stretched automatically, this allows     to adjust the initial scale of the target :class:`~.Mobject` while     it is shifted in. Setting this to 0, 1, and 2, respectively,     matches the length of the target with the length of the starting     :class:`~.Mobject` in x, y, and z direction, respectively. kwargs     Further keyword arguments are passed to the parent class.  Examples --------  .. manim:: DifferentFadeTransforms      class DifferentFadeTransforms(Scene):         def construct(self):             starts = [Rectangle(width=4, height=1) for _ in range(3)]             VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)             targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]             VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)              self.play(*[FadeIn(s) for s in starts])             self.play(                 FadeTransform(starts[0], targets[0], stretch=True),                 FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),                 FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)             )              self.play(*[FadeOut(mobj) for mobj in self.mobjects])"
FadeTransformPieces,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Fades submobjects of one mobject into submobjects of another one.  See also -------- :class:`~.FadeTransform`  Examples -------- .. manim:: FadeTransformSubmobjects      class FadeTransformSubmobjects(Scene):         def construct(self):             src = VGroup(Square(), Circle().shift(LEFT + UP))             src.shift(3*LEFT + 2*UP)             src_copy = src.copy().shift(4*DOWN)              target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))             target.shift(3*RIGHT + 2*UP)             target_copy = target.copy().shift(4*DOWN)              self.play(FadeIn(src), FadeIn(src_copy))             self.play(                 FadeTransform(src, target),                 FadeTransformPieces(src_copy, target_copy)             )             self.play(*[FadeOut(mobj) for mobj in self.mobjects])"
FadeTransformPieces,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Fades submobjects of one mobject into submobjects of another one.  See also -------- :class:`~.FadeTransform`  Examples -------- .. manim:: FadeTransformSubmobjects      class FadeTransformSubmobjects(Scene):         def construct(self):             src = VGroup(Square(), Circle().shift(LEFT + UP))             src.shift(3*LEFT + 2*UP)             src_copy = src.copy().shift(4*DOWN)              target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))             target.shift(3*RIGHT + 2*UP)             target_copy = target.copy().shift(4*DOWN)              self.play(FadeIn(src), FadeIn(src_copy))             self.play(                 FadeTransform(src, target),                 FadeTransformPieces(src_copy, target_copy)             )             self.play(*[FadeOut(mobj) for mobj in self.mobjects])"
MoveToTarget,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Transforms a mobject to the mobject stored in its ``target`` attribute.  After calling the :meth:`~.Mobject.generate_target` method, the :attr:`target` attribute of the mobject is populated with a copy of it. After modifying the attribute, playing the :class:`.MoveToTarget` animation transforms the original mobject into the modified one stored in the :attr:`target` attribute.  Examples --------  .. manim:: MoveToTargetExample      class MoveToTargetExample(Scene):         def construct(self):             c = Circle()              c.generate_target()             c.target.set_fill(color=GREEN, opacity=0.5)             c.target.shift(2*RIGHT + UP).scale(0.5)              self.add(c)             self.play(MoveToTarget(c))"
ReplacementTransform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Replaces and morphs a mobject into a target mobject.  Parameters ---------- mobject     The starting :class:`~.Mobject`. target_mobject     The target :class:`~.Mobject`. kwargs     Further keyword arguments that are passed to :class:`Transform`.  Examples --------  .. manim:: ReplacementTransformOrTransform     :quality: low      class ReplacementTransformOrTransform(Scene):         def construct(self):             # set up the numbers             r_transform = VGroup(*[Integer(i) for i in range(1,4)])             text_1 = Text(""ReplacementTransform"", color=RED)             r_transform.add(text_1)              transform = VGroup(*[Integer(i) for i in range(4,7)])             text_2 = Text(""Transform"", color=BLUE)             transform.add(text_2)              ints = VGroup(r_transform, transform)             texts = VGroup(text_1, text_2).scale(0.75)             r_transform.arrange(direction=UP, buff=1)             transform.arrange(direction=UP, buff=1)              ints.arrange(buff=2)             self.add(ints, texts)              # The mobs replace each other and none are left behind             self.play(ReplacementTransform(r_transform[0], r_transform[1]))             self.play(ReplacementTransform(r_transform[1], r_transform[2]))              # The mobs linger after the Transform()             self.play(Transform(transform[0], transform[1]))             self.play(Transform(transform[1], transform[2]))             self.wait()"
Restore,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Transforms a mobject to its last saved state.  To save the state of a mobject, use the :meth:`~.Mobject.save_state` method.  Examples --------  .. manim:: RestoreExample      class RestoreExample(Scene):         def construct(self):             s = Square()             s.save_state()             self.play(FadeIn(s))             self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))             self.play(s.animate.shift(5*DOWN).rotate(PI/4))             self.wait()             self.play(Restore(s), run_time=2)"
Restore,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Transforms a mobject to its last saved state.  To save the state of a mobject, use the :meth:`~.Mobject.save_state` method.  Examples --------  .. manim:: RestoreExample      class RestoreExample(Scene):         def construct(self):             s = Square()             s.save_state()             self.play(FadeIn(s))             self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))             self.play(s.animate.shift(5*DOWN).rotate(PI/4))             self.wait()             self.play(Restore(s), run_time=2)"
ScaleInPlace,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Animation that scales a mobject by a certain factor.  Examples --------  .. manim:: ScaleInPlaceExample      class ScaleInPlaceExample(Scene):         def construct(self):             self.play(ScaleInPlace(Text(""Hello World!""), 2))"
ShrinkToCenter,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Animation that makes a mobject shrink to center.  Examples --------  .. manim:: ShrinkToCenterExample      class ShrinkToCenterExample(Scene):         def construct(self):             self.play(ShrinkToCenter(Text(""Hello World!"")))"
Swap,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"An animation moving mobjects cyclically.  In particular, this means: the first mobject takes the place of the second mobject, the second one takes the place of the third mobject, and so on. The last mobject takes the place of the first one.  Parameters ---------- mobjects     List of mobjects to be transformed. path_arc     The angle of the arc (in radians) that the mobjects will follow to reach     their target. kwargs     Further keyword arguments that are passed to :class:`.Transform`.  Examples -------- .. manim :: CyclicReplaceExample      class CyclicReplaceExample(Scene):         def construct(self):             group = VGroup(Square(), Circle(), Triangle(), Star())             group.arrange(RIGHT)             self.add(group)              for _ in range(4):                 self.play(CyclicReplace(*group))"
Transform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
Transform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
Transform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
Transform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
Transform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
Transform,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
TransformAnimations,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"A Transform transforms a Mobject into a target Mobject.  Parameters ---------- mobject     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``. target_mobject     The target of the transformation. path_func     A function defining the path that the points of the ``mobject`` are being moved     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`. path_arc     The arc angle (in radians) that the points of ``mobject`` will follow to reach     the points of the target if using a circular path arc, see ``path_arc_centers``.     See also :func:`manim.utils.paths.path_along_arc`. path_arc_axis     The axis to rotate along if using a circular path arc, see ``path_arc_centers``. path_arc_centers     The center of the circular arcs along which the points of ``mobject`` are     moved by the transformation.      If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it. replace_mobject_with_target_in_scene     Controls which mobject is replaced when the transformation is complete.      If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.  Examples --------  .. manim :: TransformPathArc      class TransformPathArc(Scene):         def construct(self):             def make_arc_path(start, end, arc_angle):                 points = []                 p_fn = path_along_arc(arc_angle)                 # alpha animates between 0.0 and 1.0, where 0.0                 # is the beginning of the animation and 1.0 is the end.                 for alpha in range(0, 11):                     points.append(p_fn(start, end, alpha / 10.0))                 path = VMobject(stroke_color=YELLOW)                 path.set_points_smoothly(points)                 return path              left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)             colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]             # Positive angles move counter-clockwise, negative angles move clockwise.             examples = [-90, 0, 30, 90, 180, 270]             anims = []             for idx, angle in enumerate(examples):                 left_c = left.copy().shift((3 - idx) * UP)                 left_c.fill_color = colors[idx]                 right_c = left_c.copy().shift(4 * RIGHT)                 path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),                                          arc_angle=angle * DEGREES)                 desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)                 # Make the circles in front of the text in front of the arcs.                 self.add(                     path_arc.set_z_index(1),                     desc.set_z_index(2),                     left_c.set_z_index(3),                 )                 anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))              self.play(*anims, run_time=2)             self.wait()"
TransformFromCopy,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,Performs a reversed Transform
_MethodAnimation,manim.animation.transform,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform.py,"Transforms a mobject to the mobject stored in its ``target`` attribute.  After calling the :meth:`~.Mobject.generate_target` method, the :attr:`target` attribute of the mobject is populated with a copy of it. After modifying the attribute, playing the :class:`.MoveToTarget` animation transforms the original mobject into the modified one stored in the :attr:`target` attribute.  Examples --------  .. manim:: MoveToTargetExample      class MoveToTargetExample(Scene):         def construct(self):             c = Circle()              c.generate_target()             c.target.set_fill(color=GREEN, opacity=0.5)             c.target.shift(2*RIGHT + UP).scale(0.5)              self.add(c)             self.play(MoveToTarget(c))"
TransformMatchingAbstractBase,manim.animation.transform_matching_parts,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform_matching_parts.py,"Abstract base class for transformations that keep track of matching parts.  Subclasses have to implement the two static methods :meth:`~.TransformMatchingAbstractBase.get_mobject_parts` and :meth:`~.TransformMatchingAbstractBase.get_mobject_key`.  Basically, this transformation first maps all submobjects returned by the ``get_mobject_parts`` method to certain keys by applying the ``get_mobject_key`` method. Then, submobjects with matching keys are transformed into each other.  Parameters ---------- mobject     The starting :class:`~.Mobject`. target_mobject     The target :class:`~.Mobject`. transform_mismatches     Controls whether submobjects without a matching key are transformed     into each other by using :class:`~.Transform`. Default: ``False``. fade_transform_mismatches     Controls whether submobjects without a matching key are transformed     into each other by using :class:`~.FadeTransform`. Default: ``False``. key_map     Optional. A dictionary mapping keys belonging to some of the starting mobject's     submobjects (i.e., the return values of the ``get_mobject_key`` method)     to some keys belonging to the target mobject's submobjects that should     be transformed although the keys don't match. kwargs     All further keyword arguments are passed to the submobject transformations.   Note ---- If neither ``transform_mismatches`` nor ``fade_transform_mismatches`` are set to ``True``, submobjects without matching keys in the starting mobject are faded out in the direction of the unmatched submobjects in the target mobject, and unmatched submobjects in the target mobject are faded in from the direction of the unmatched submobjects in the start mobject."
TransformMatchingShapes,manim.animation.transform_matching_parts,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform_matching_parts.py,"An animation trying to transform groups by matching the shape of their submobjects.  Two submobjects match if the hash of their point coordinates after normalization (i.e., after translation to the origin, fixing the submobject height at 1 unit, and rounding the coordinates to three decimal places) matches.  See also -------- :class:`~.TransformMatchingAbstractBase`  Examples --------  .. manim:: Anagram      class Anagram(Scene):         def construct(self):             src = Text(""the morse code"")             tar = Text(""here come dots"")             self.play(Write(src))             self.wait(0.5)             self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))             self.wait(0.5)"
TransformMatchingTex,manim.animation.transform_matching_parts,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/transform_matching_parts.py,"A transformation trying to transform rendered LaTeX strings.  Two submobjects match if their ``tex_string`` matches.  See also -------- :class:`~.TransformMatchingAbstractBase`  Examples --------  .. manim:: MatchingEquationParts      class MatchingEquationParts(Scene):         def construct(self):             variables = VGroup(MathTex(""a""), MathTex(""b""), MathTex(""c"")).arrange_submobjects().shift(UP)              eq1 = MathTex(""{{x}}^2"", ""+"", ""{{y}}^2"", ""="", ""{{z}}^2"")             eq2 = MathTex(""{{a}}^2"", ""+"", ""{{b}}^2"", ""="", ""{{c}}^2"")             eq3 = MathTex(""{{a}}^2"", ""="", ""{{c}}^2"", ""-"", ""{{b}}^2"")              self.add(eq1)             self.wait(0.5)             self.play(TransformMatchingTex(Group(eq1, variables), eq2))             self.wait(0.5)             self.play(TransformMatchingTex(eq2, eq3))             self.wait(0.5)"
MaintainPositionRelativeTo,manim.animation.updaters.update,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/updaters/update.py,"An animation.  Animations have a fixed time span.  Parameters ---------- mobject     The mobject to be animated. This is not required for all types of animations. lag_ratio     Defines the delay after which the animation is applied to submobjects. This lag     is relative to the duration of the animation.      This does not influence the total     runtime of the animation. Instead the runtime of individual animations is     adjusted so that the complete animation has the defined run time.  run_time     The duration of the animation in seconds. rate_func     The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .      For example ``rate_func(0.5)`` is the proportion of the animation that is done     after half of the animations run time.   reverse_rate_function     Reverses the rate function of the animation. Setting ``reverse_rate_function``     does not have any effect on ``remover`` or ``introducer``. These need to be     set explicitly if an introducer-animation should be turned into a remover one     and vice versa. name     The name of the animation. This gets displayed while rendering the animation.     Defaults to <class-name>(<Mobject-name>). remover     Whether the given mobject should be removed from the scene after this animation. suspend_mobject_updating     Whether updaters of the mobject should be suspended during the animation.   .. NOTE::      In the current implementation of this class, the specified rate function is applied     within :meth:`.Animation.interpolate_mobject` call as part of the call to     :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`     that are implemented by overriding :meth:`interpolate_mobject`, the rate function     has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead     of just ``alpha``).   Examples --------  .. manim:: LagRatios      class LagRatios(Scene):         def construct(self):             ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios              # Create dot groups             group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()             groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)             self.add(groups)              # Label groups             self.add(Text(""lag_ratio = "", font_size=36).next_to(groups, UP, buff=1.5))             for group, ratio in zip(groups, ratios):                 self.add(Text(str(ratio), font_size=36).next_to(group, UP))              #Animate groups with different lag_ratios             self.play(AnimationGroup(*[                 group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)                 for group, ratio in zip(groups, ratios)             ]))              # lag_ratio also works recursively on nested submobjects:             self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))"
UpdateFromAlphaFunc,manim.animation.updaters.update,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/updaters/update.py,"update_function of the form func(mobject), presumably to be used when the state of one mobject is dependent on another simultaneously animated mobject"
UpdateFromFunc,manim.animation.updaters.update,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/updaters/update.py,"update_function of the form func(mobject), presumably to be used when the state of one mobject is dependent on another simultaneously animated mobject"
UpdateFromFunc,manim.animation.updaters.update,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/animation/updaters/update.py,"update_function of the form func(mobject), presumably to be used when the state of one mobject is dependent on another simultaneously animated mobject"

Scenes
Class Name,Module,File Path,Description
MovingCameraScene,manim.scene.moving_camera_scene,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/scene/moving_camera_scene.py,"This is a Scene, with special configurations and properties that make it suitable for cases where the camera must be moved around.  Note: Examples are included in the moving_camera_scene module documentation, see below in the 'see also' section.  .. SEEALSO::      :mod:`.moving_camera_scene`     :class:`.MovingCamera`"
MovingCameraScene,manim.scene.moving_camera_scene,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/scene/moving_camera_scene.py,"This is a Scene, with special configurations and properties that make it suitable for cases where the camera must be moved around.  Note: Examples are included in the moving_camera_scene module documentation, see below in the 'see also' section.  .. SEEALSO::      :mod:`.moving_camera_scene`     :class:`.MovingCamera`"
SpecialThreeDScene,manim.scene.three_d_scene,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/scene/three_d_scene.py,"An extension of :class:`ThreeDScene` with more settings.  It has some extra configuration for axes, spheres, and an override for low quality rendering. Further key differences are:  * The camera shades applicable 3DMobjects by default,   except if rendering in low quality. * Some default params for Spheres and Axes have been added."
ThreeDScene,manim.scene.three_d_scene,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/scene/three_d_scene.py,"This is a Scene, with special configurations and properties that make it suitable for Three Dimensional Scenes."
LinearTransformationScene,manim.scene.vector_space_scene,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/scene/vector_space_scene.py,"This scene contains special methods that make it especially suitable for showing linear transformations.  Parameters ---------- include_background_plane     Whether or not to include the background plane in the scene. include_foreground_plane     Whether or not to include the foreground plane in the scene. background_plane_kwargs     Parameters to be passed to :class:`NumberPlane` to adjust the background plane. foreground_plane_kwargs     Parameters to be passed to :class:`NumberPlane` to adjust the foreground plane. show_coordinates     Whether or not to include the coordinates for the background plane. show_basis_vectors     Whether to show the basis x_axis -> ``i_hat`` and y_axis -> ``j_hat`` vectors. basis_vector_stroke_width     The ``stroke_width`` of the basis vectors. i_hat_color     The color of the ``i_hat`` vector. j_hat_color     The color of the ``j_hat`` vector. leave_ghost_vectors     Indicates the previous position of the basis vectors following a transformation.  Examples -------  .. manim:: LinearTransformationSceneExample      class LinearTransformationSceneExample(LinearTransformationScene):         def __init__(self, **kwargs):             LinearTransformationScene.__init__(                 self,                 show_coordinates=True,                 leave_ghost_vectors=True,                 **kwargs             )          def construct(self):             matrix = [[1, 1], [0, 1]]             self.apply_matrix(matrix)             self.wait()"
VectorScene,manim.scene.vector_space_scene,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/scene/vector_space_scene.py,"A Scene is the canvas of your animation.  The primary role of :class:`Scene` is to provide the user with tools to manage mobjects and animations.  Generally speaking, a manim script consists of a class that derives from :class:`Scene` whose :meth:`Scene.construct` method is overridden by the user's code.  Mobjects are displayed on screen by calling :meth:`Scene.add` and removed from screen by calling :meth:`Scene.remove`.  All mobjects currently on screen are kept in :attr:`Scene.mobjects`.  Animations are played by calling :meth:`Scene.play`.  A :class:`Scene` is rendered internally by calling :meth:`Scene.render`.  This in turn calls :meth:`Scene.setup`, :meth:`Scene.construct`, and :meth:`Scene.tear_down`, in that order.  It is not recommended to override the ``__init__`` method in user Scenes.  For code that should be ran before a Scene is rendered, use :meth:`Scene.setup` instead.  Examples -------- Override the :meth:`Scene.construct` method with your code.  .. code-block:: python      class MyScene(Scene):         def construct(self):             self.play(Write(Text(""Hello World!"")))"
ZoomedScene,manim.scene.zoomed_scene,/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/manim/scene/zoomed_scene.py,This is a Scene with special configurations made for when a particular part of the scene must be zoomed in on and displayed separately.

